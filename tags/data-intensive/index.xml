<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data-Intensive on 2cloudlab | 企业数字化转型的催化剂</title>
    <link>https://2cloudlab.com/tags/data-intensive/</link>
    <description>Recent content in Data-Intensive on 2cloudlab | 企业数字化转型的催化剂</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 15 Mar 2020 12:27:38 +0600</lastBuildDate>
    
	<atom:link href="https://2cloudlab.com/tags/data-intensive/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DynamoDB的学习指南</title>
      <link>https://2cloudlab.com/nosql/nosql-index/</link>
      <pubDate>Sun, 15 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/nosql-index/</guid>
      <description>如果你在软件行业（尤其是后端服务的研发）里从业几年，你肯定会听说过与存储和处理数据相关的几个时髦的技术词：NoSQL，大数据，云计算，ServerLess，ACID，CAP，分布式等等。驱动这些技术发展的原因是多样的，主要有以下几点：
 互联网巨头（比如Google，Microsoft，Amazon，Facebook，LinkedIn，Netflix以及Twitter）需要面对体量庞大的数据和流量，这迫使它们创造新的工具来高效处理海量数据 需要更短的研发周期和更灵活的数据模型支撑更加敏捷，更加容易测试和及时响应市场的业务场景 开源软件的发展变得更加成熟，而且与商业软件相比，提供了更好的功能 CPU的时钟频率很难提高，多核CPU已经逐渐成为标准，网络变得更快了（从原来的2G转变成为4G，到现在的5G）。这意味着并行计算的能力将会增强 得益于云计算服务的出现，即使你在一个小团队，也能打造一个分布式系统，甚至在不同的地理位置的不同机器上运行这套系统 许多数字化服务会一直处于7*24小时可用的状态，短暂的停机是无法接受的（比如Amazon短暂地停机会导致其商品买卖交易活动停滞，并引起经济损失）  因此，过去10年，为了应对大规模数据所带来的挑战，相应的工具和技术相继被提出。其中新型数据库系统（&amp;quot;NoSQL&amp;quot;）受到了很多关注，但是消息队列（message queues），缓存（caches），搜索引擎，数据流处理框架（Kafka和Samza）和其它分布式技术也相当重要！一个成熟的分布式系统一般会同时应用这些技术和工具。
以上提到的技术和工具都有对应的书籍介绍，而这个系列的文章（其列表如下）将聚焦在NoSQL数据库上，特别是AWS提供的DynamoDB。对于想要从事数据服务研发的工程师们，掌握NoSQL技能是必备的，因为它能够存储大规模数据（超过100TBs）的同时提供稳定的性能（数据操作的时间低于1ms），而要想在SQL数据库中拥有同样的能力，则需要付出巨大的代价，有时甚至无法实现！
NoSQL类型的数据库有很多，包括MongoDB，CouchDB和DynamoDB等。之所以使用DynamoDB的原因之一是它完全托管于AWS，开发者无需准备运行它的机器就能直接创建表。除此之外，DynamoDB还提供了永久的免费套餐。基于DynamoDB的这些优势，你准备好了吗？
介绍  1.1 什么是DynamoDB？ 1.2 DynamoDB的关键概念 1.3 关于Dynamo的论文 1.4 DynamoDB的环境搭建  单项数据操作  2.1 DynamoDB中，每项数据（item）的构成单元 2.2 在DynamoDB中插入和读取数据项 2.3 基础表达式 2.4 更新和删除数据项  多项数据操作  3.1 同时处理多项数据 3.2 查询 3.3 遍历 3.4 过滤  高级功能  4.1 附加索引 4.2 本地附加索引 4.3 全局附加索引 4.4 DynamoDB流  运维相关  5.1 Provisioning tables 5.2 安全 5.3 备份和恢复 5.4 自动伸缩 5.5 Global Tables  数据建模案例  6.</description>
    </item>
    
    <item>
      <title>更新和删除数据项</title>
      <link>https://2cloudlab.com/nosql/updating-deleting-items/</link>
      <pubDate>Tue, 25 Feb 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/updating-deleting-items/</guid>
      <description>在这篇文章中，我们将学习如何向表中更新和删除单项数据。这是最后一篇关于单项数据操作的文章，后续的文章将涉及多个数据项的操作，这些操作主要有Queries和Scans。
更新单项数据 在之前的例子中，我们使用PutItem操作来向表中插入单项数据。我们也看到这种操作将会完全覆盖表中已存在的数据。为了不让这个操作覆盖已存在的数据项，我们在这个操作上使用了条件表达式。
有时需要处理这种场景：只更新某项数据的一个或者多个属性，而其它属性保持不变。为了处理这种场景，DynamoDB提供了UpdateItem操作，该操作允许开发者在不读取数据的情况下更新数据。
当使用UpdateItem操作时，你需要指定更新表达式，该表达式由2部分构成，分别是：更新的语义（比如是向数据项中添加属性还是移除属性）和表达式。
当使用更新表达式时，你必须提供以下更新的语义：
 SET: 这个操作用于向数据项中添加新的属性，或者覆盖已有属性 REMOVE: 该操作用于移除数据项中某一个属性 ADD: 对于数值类型的属性，该操作代表加或减；对于集合类型的属性，该操作代表向集合中插入元素 DELETE: 用于从集合中删除元素  让我们通过几个例子来了解更新操作的使用。
 使用带有SET语义的UpdateItem  在更新数据项时，最常用的更新操作是SET。比如，如果我想向某项数据添加一个新的属性或者覆盖已有的属性，那么这个SET操作会被用到。
让我们看看最开始的例子：PutItem，假设，我们想让已经添加的用户拥有属性DateOfBirth。 如果不使用UpdateItem操作，我们的做法是首先通过GetItem获取该数据项，然后通过PutItem插入一项包含DateOfBirth属性的数据项。然而通过UpdateItem操作，我们只需要直接插入属性DateOfBirth即可，如下所示：
$ aws dynamodb update-item \  --table-name Users \  --key &amp;#39;{ &amp;#34;Username&amp;#34;: {&amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34;} }&amp;#39; \  --update-expression &amp;#39;SET #dob = :dob&amp;#39; \  --expression-attribute-names &amp;#39;{ &amp;#34;#dob&amp;#34;: &amp;#34;DateOfBirth&amp;#34; }&amp;#39; \  --expression-attribute-values &amp;#39;{ &amp;#34;:dob&amp;#34;: {&amp;#34;S&amp;#34;: &amp;#34;1937-04-17&amp;#34;} }&amp;#39; \  $LOCAL 注意我们使用了选项--expression-attribute-names和--expression-attribute-values。
如果我们再次获取该数据项，那么我们不仅能看到之前的属性，而且还能看到新添的属性，如下所示：
$ aws dynamodb get-item \  --table-name Users \  --key &amp;#39;{ &amp;#34;Username&amp;#34;: {&amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34;} }&amp;#39; \  $LOCAL { &amp;#34;Item&amp;#34;: { &amp;#34;Username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; }, &amp;#34;DateOfBirth&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;1937-04-17&amp;#34; }, &amp;#34;Age&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;81&amp;#34; }, &amp;#34;Name&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;Daffy Duck&amp;#34; } } }  使用带有REMOVE语义的UpdateItem  带有REMOVE语义的UpdateItem操作与带有SET语义的UpdateItem操作相反&amp;ndash;它用于从一个数据项中删除指定属性。</description>
    </item>
    
    <item>
      <title>DynamoDB的基础表达式</title>
      <link>https://2cloudlab.com/nosql/expression-basics/</link>
      <pubDate>Mon, 24 Feb 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/expression-basics/</guid>
      <description>本文是关于DynamoDB的表达式。表达式是DynamoDB的内置功能，它又细分为以下几类表达式：
 条件表达式只能与单项数据的操作配合起来使用，这些操作有PutItem，UpdateItem和DeleteItem。当你为单项数据的操作指定条件表达式时，只有当该表达式的验证结果为true时，该操作才能执行，对应的指令选项是--condition-expression 属性映射表达式通常会与读取数据项的操作配合起来使用，比如之前的GetItem例子就使用了属性映射表达式，它的作用在于仅返回该项数据的部分属性，对应的指令选项是--projection-expression 更新表达式用于更新已经存在的数据项上的某些属性，对应的指令选项是--update-expression 主键条件表达式通常会与查询操作（比如Query）一起使用，这类表达式的条件只能是与主键相关，对应的指令选项是--key-condition-expression 过滤表达式通常会与查询操作或遍历操作一起使用，它将作用于查询结果之上，对应的指令选项是--filter-expression  只有充分理解了这些表达式，才能更好地使用DynamoDB，进而享受DynamoDB给我们带来的好处。在这篇文章，我们将学习表达式的基础知识，包括使用表达式的属性名和属性值。紧接着，我们将基于上一章关于PutItem的例子来学习如何使用条件表达式。
表达式的基础知识 DynamoDB中的表达式只是一串字符串，它的内容是特定的逻辑表达式，而这个表达式将用来验证数据是否满足该条件。在这些表达式中，你可以应用一些比较操作符，比如&amp;quot;=&amp;rdquo;（相等），&amp;ldquo;&amp;gt;&amp;rdquo;（大于）或者&amp;quot;&amp;gt;=&amp;rdquo;（大于等于）。例如，以下表达式应用了&amp;quot;&amp;gt;=&amp;rdquo;：
&amp;#34;Age &amp;gt;= 21&amp;#34; 该表达式的作用在于：该操作只能作用于年龄在21岁及以上的用户，否则操作结果会出错。
 注意：以上表达式还无法生效，原因在于该表达式没有指定&amp;quot;21&amp;quot;的类型。为了使以上表达式生效，你需要指定expression attribute values，也就是使用指令属性--expression-attribute-values，这一点将在后面提到。
 除了可以在表达式中使用比较操作符，还可以在表达式中使用函数。这些函数是DynamoDB提供的，它们有：attribute_exists()，判断某项数据其属性是存在的；attribute_not_exists()，判断某项数据其属性是不存在的；begins_with()，判断某项数据其属性值是以某个子字符串开始的。
我们可以在表达式中使用attribute_not_exists()函数来判断某个订单是否已经发货了，其用法如下所示：
&amp;#34;attribute_not_exists(DateShipped)&amp;#34; 如果该订单有DateShipped属性，那么表明它已经发货了，否则表明它还在仓库中。DynamoDB提供的函数不多，所有的函数如下所示：
 attribute_exists(): 判断某项数据其属性是存在的 attribute_not_exists(): 判断某项数据其属性是不存在的 attribute_type(): 判断某项数据其属性的类型是指定的类型 begins_with(): 判断某项数据其属性值是以某个子字符串开始的 contains(): 如果该属性是字符串类型，则判断某项数据其属性值是包含某个子字符串的；如果该属性是集合类型（比如List或Map），则判断该属性是包含指定元素的 size(): 返回属性的大小，不同类型的属性，其大小的计算规则是不一样的。  关于表达式中的比较操作符和函数，读者可以参考官方文档。
表达式的占位符 之前的内容表明，表达式是一个具有逻辑运算的字符串，DynamoDB通过执行这个表达式来得到一个是或否的结果。然而，有的时候你需要一种更加清晰的方式来编写表达式，比如在表达式中使用变量，然后在其它地方提供变量值。
DynamoDB允许你使用--expression-attribute-names和--expression-attribute-values选项来编写更加清晰的表达式。通过这种做法，你可以在表达式中指定变量，然后分别使用以上选项来指定变量值，DynamoDB会将这些变量值自动替换掉表达式中的变量。接下来，让我们看看这2个选项的含义。
 --expression-attribute-names  有时，你希望针对一个属性编写表达式，但是由于DynamoDB的限制，你无法直接在表达式中使用该属性名，比如：
 你的属性名称刚好是DynamoDB中预留的关键字。DynamoDB预先保留了大量的关键字，其中包括了：&amp;ldquo;Date&amp;rdquo;，&amp;ldquo;Year&amp;quot;和&amp;quot;Name&amp;quot;等。如果你的属性名称恰巧在这些预留的关键字里，那么你需要借助这个选项来提供属性名称的占位符 你的属性名称中包含&amp;rdquo;.&amp;quot;。DynamoDB使用&amp;rdquo;.&amp;ldquo;来获取嵌套类型（比如Map类型）中的子项。如果你的属性名中包含了&amp;rdquo;.&amp;quot;，那么你需要借助这个选项来提供属性名称的占位符 你的属性名称开头包含数字。DynamoDB不允许表达式中的属性名称以数字开头，因此如果你的属性名称以数字开头，那么你需要借助这个选项来提供属性名称的占位符  在使用这个选项时，你只需要提供一个Map格式的属性名称集合。这个Map中的key是表达式中的占位符，而value是属性名称。例如，你可以为&amp;quot;Age&amp;quot;属性定义占位符&amp;rdquo;#a&amp;rdquo;，而这个占位符可用于表达式，具体示例如下所示：
--expression-attribute-names &amp;#39;{ &amp;#34;#a&amp;#34;: &amp;#34;Age&amp;#34; }&amp;#39;  当使用--expression-attribute-names时，占位符必须以&amp;rdquo;#&amp;ldquo;开头。
 在之前的GetItem的例子中，我们使用了--projection-expression选项来返回某项数据的部分属性。为了能够在该选项中使用占位符，我们需要将之前的例子改如下：
$ aws dynamodb get-item \  --table-name Users \  --projection-expression &amp;#34;#a, #u&amp;#34; \  --expression-attribute-names &amp;#39;{ &amp;#34;#a&amp;#34;: &amp;#34;Age&amp;#34;, &amp;#34;#u&amp;#34;: &amp;#34;Username&amp;#34; }&amp;#39; \  --key &amp;#39;{ &amp;#34;Username&amp;#34;: {&amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34;} }&amp;#39; \  $LOCAL { &amp;#34;Item&amp;#34;: { &amp;#34;Username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; }, &amp;#34;Age&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;81&amp;#34; } } } 注意，在以上例子中，我们在--projection-expression中使用了2个占位符，分别是&amp;rdquo;#a&amp;quot;和&amp;rdquo;#u&amp;rdquo;。而这2个占位符定义在--expression-attribute-names选项中，分别对应&amp;quot;Age&amp;quot;和&amp;quot;Username&amp;quot;属性。</description>
    </item>
    
    <item>
      <title>如何在DynamoDB中同时操作多项数据</title>
      <link>https://2cloudlab.com/nosql/working-with-multiple-items/</link>
      <pubDate>Tue, 26 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/working-with-multiple-items/</guid>
      <description>在过去的章节里，我们一次只能操作一项数据&amp;ndash;比如插入，查找，更新以及删除单项数据。而在这篇文章里，我们将一次同时操作多项数据。从这章开始，我们将创建一张具有复合主键的表，并在该表中同时操作多项数据。
复合主键对于DynamoDB而言非常有用。它允许你通过一个查询操作就能获取一组相关的数据项，除此之外，它还有其它强大的用途。
本文将创建一张具有复合主键的表。然后我们将使用BatchWriteItem API来批量生成多项数据。后续的几篇文章将使用Query和Scan API作用到这些数据。
创建表 创建一张具有复合主键的表与创建一张具有简单主键的表类似，都需要定义属性和key schema。不同的是，你需要指定2个属性构成复合主键，而不是1个。 然后你需要指定其中一个属性是分区键，另外一个属性是排序键。
分区键决定了你的数据是如何划分的，而排序键则决定了具有相同分期键的数据项是有序的。分区键尤其重要-当使用Query操作时，你只能使用分区键。分区键与排序键组合在一起可以建立一对多的数据模型-因为一个相同的分区键下，可以有多个不同的排序键。
每当需要基于复合主键来对数据建模时，可以根据以下句子来填写空格处，最终构建正确的查询模式：
 &amp;ldquo;Give me all of the ____ from a particular ___.&amp;rdquo;
 放入第一个空格的属性应该是排序键，而放到最后一个空格的属性则是分区键。在以下示例中，我们将创建一张即包含User类型数据，同时也会包含Order类型数据的表：&amp;ldquo;UserOrdersTable&amp;rdquo;，其中每个User可以包含多个Orders。按照以上句子来构建查询模型，其最终的结果是：&amp;ldquo;返回该Username的所有OrderIds&amp;rdquo;。基于这句话，可以得出：Username是分区键，而OrderId则是排序键。
为了创建&amp;quot;UserOrdersTable&amp;rdquo;，需要使用CreateTable API：
$ aws dynamodb create-table \  --table-name UserOrdersTable \  --attribute-definitions &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;OrderId&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; } ]&amp;#39; \  --key-schema &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;HASH&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;OrderId&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;RANGE&amp;#34; } ]&amp;#39; \  --provisioned-throughput &amp;#39;{ &amp;#34;ReadCapacityUnits&amp;#34;: 1, &amp;#34;WriteCapacityUnits&amp;#34;: 1 }&amp;#39; \  $LOCAL 返回的结果如下所示：</description>
    </item>
    
    <item>
      <title>在DynamoDB中插入和读取数据项</title>
      <link>https://2cloudlab.com/nosql/inserting-retrieving-items/</link>
      <pubDate>Sat, 23 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/inserting-retrieving-items/</guid>
      <description>数据项是DynamoDB的基础单元，每一张表都会包含多项数据。接下来，在本文中，我们将向DynamoDB中插入和读取数据项。我们将创建Users表，并为该表指定一个简单键：Username。接着，我们将操作2个基本的接口：PutItem和GetItem。下一篇文章，我们将在这篇文章的基础上应用表达式来实现更加复杂的查询功能。在这之后，我们将另起一篇文章来讲解如何更新和删除数据项。
 为了能顺利操作本文所列举的示例，请确保DynamoDB的环境已经准备好。注意：如果你使用的是本地版本的DynamoDB，那么请确保$LOCAL变量配置正确，如果使用的是AWS上的DynamoDB，那么在每一个命令后面无需追加这个参数。
 创建表 在演练本文列举的用例之前，首先需要创建一张表。我们将创建一张表&amp;quot;Users&amp;rdquo;，并为该表定义了一个简单主键：&amp;ldquo;Username&amp;rdquo;，它的类型是string。
当创建表时，你需要为主键或索引提供属性定义。这些属性定义包含了属性名和属性类型。在Users这张表中，我们使用&amp;quot;Username&amp;quot;作为主键，其类型是string（&amp;ldquo;S&amp;rdquo;）。除此之外，你还需要为该表定义KeySchema，其中指定了哪些属性构成主键以及这些属性是HASH键还是RANGE键。在以下示例中，属性&amp;quot;Username&amp;quot;构成了该表的简单主键。最后，你需要指定表名和表的吞吐单元，其中吞吐单元由读和写单元构成。在以下示例中，&amp;ldquo;Users&amp;quot;表的读写单元都是1，简单来说，越多的读写单元，单位时间内读写数据的速度越快和越多，反之亦然！
有了以上概念, 让我们运行以下指令来创建表&amp;quot;Users&amp;rdquo;:
$ aws dynamodb create-table \  --table-name Users \  --attribute-definitions &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; } ]&amp;#39; \  --key-schema &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;HASH&amp;#34; } ]&amp;#39; \  --provisioned-throughput &amp;#39;{ &amp;#34;ReadCapacityUnits&amp;#34;: 1, &amp;#34;WriteCapacityUnits&amp;#34;: 1 }&amp;#39; \  $LOCAL 如果创建表的操作成功了，你将看到以下返回结果：
{ &amp;#34;TableDescription&amp;#34;: { &amp;#34;TableArn&amp;#34;: &amp;#34;arn:aws:dynamodb:ddblocal:000000000000:table/Users&amp;#34;, &amp;#34;AttributeDefinitions&amp;#34;: [ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; } ], &amp;#34;ProvisionedThroughput&amp;#34;: { &amp;#34;NumberOfDecreasesToday&amp;#34;: 0, &amp;#34;WriteCapacityUnits&amp;#34;: 1, &amp;#34;LastIncreaseDateTime&amp;#34;: 0.</description>
    </item>
    
    <item>
      <title>DynamoDB中，每项数据（item）的构成单元</title>
      <link>https://2cloudlab.com/nosql/anatomy-of-an-item/</link>
      <pubDate>Fri, 22 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/anatomy-of-an-item/</guid>
      <description>DynamoDB中的每条数据是构成整个数据集的基础，它对应着关系型数据库中的某一张表中的某一行数据或者对应MongoDB中一个文档，又或者是编程当中的一个对象（比如一个用户对象）。每条数据由主键唯一标识，而主键是在创建表的时候指定的。除了主键之外，每条数据也可以包含其它属性，这些属性与主键组成了一条完整的数据单元（比如：一个用户数据由user_id, name, phone组成，其中user_id是主键）。每个属性（包括主键）都有对应类型，比如string，numbers，lists，sets等，当写入或查询数据的时候，这些类型都需要提供。在这篇文章中，我们将通过以下几个方面来讨论构成每项数据的基础单元：
 主键 属性 属性的类型  主键  表中的每项数据都由主键唯一标识
 每当创建一张表的时，你需要为该表指定一个主键。每项数据由主键唯一标识，而且每当向表中插入一项数据时，该项数据必须包含主键信息。
Dynamo支持2种主键。一种是简单主键，这种主键只使用了一个属性标识每一项数据，比如用户名或者订单编号。使用简单主键来写入或查询数据时有点类似于key-value数据库，比如Memcached。另外一种是复合主键，这种主键使用了2个属性来标识每一项数据。其中一个属性是分区键，它的作用在于将不同的数据划分到对应的分区。另外一个属性是排序键，它的作用是使所有具有相同分区键值的数据依据排序键进行排序。拥有复合主键的表，除了能够支持简单的写入和查询数据操作，还支持更多复杂的数据查询操作。
理解DynamoDB中表的主键对于数据建模至关重要。每当插入和更新数据时，主键都是必不可少的信息。
属性 每项数据都由多个属性构成，比如User表中的某一项数据有Name，Age，地址等属性，这些属性类似于关系型数据库中的列。DynamoDB表
DynamoDB表中每一项数据除了必须包含主键属性，其它属性不是必须的。DynamoDB是NoSQL数据库，因此它允许更加灵活的数据模型，而这一点在关系型数据库中是无法办到的。因为这种灵活的数据模型，你能在一张DynamoDB表中存储多种不同类型的数据，比如有一条Car数据，它包含产地，型号和生产年限等属性，同时在相同的表中也包含另外一条Pet数据，它包含类型，血型，年龄，颜色等属性。在DynamoDB中，一张表中同时包含不同类型的数据是常见的做法，这种做法会提高数据查询的效率！
属性的类型 当为每一项数据设置属性时，同时需要指定该属性的类型。可指定的类型有简单类型：比如，strings和numbers；也有复合类型：比如：lists，maps和sets。
每当更新或者插入数据时，需要为数据中的每一个属性指定其对应的类型。这些属性的设置需要借助一个map数据结构来完成，其中该map的keys是每一个属性名，而对应的values则是另外一个map，而这个map只有一个元素，其key是对应属性的类型，而value是对应属性的值。比如：你想存储一个用户数据，该数据包含3个属性，分别是姓名，年龄和角色，它们的类型分别是string，number和list，那么你需要为该用户数据设置如下属性信息：
{ &amp;#34;Name&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;Alex DeBrie&amp;#34; }, &amp;#34;Age&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;29&amp;#34; }, &amp;#34;Roles&amp;#34;: { &amp;#34;L&amp;#34;: [&amp;#34;Admin&amp;#34;, &amp;#34;User&amp;#34;] } } 在以上例子，我们存储了Name属性，其类型是string（通过&amp;quot;S&amp;quot;来代表），值为&amp;quot;Alex DeBrie&amp;rdquo;。此外，还存储了Age属性，其类型是number（通过&amp;quot;N&amp;quot;来代表），值为&amp;quot;29&amp;rdquo;。最后，还存储了Roles属性，其类型是list（通过&amp;quot;L&amp;quot;来代表），值为&amp;quot;Admin&amp;quot;和&amp;quot;User&amp;rdquo;。
同样，每当你从表中获取数据项时，其属性会以map的方式返回。其中，map中的keys是属性名，而values则是另外一个map，这个map的key是对应属性的类型，而value则是对应属性的值。例如，如果你使用GetItem API来获取以上用户数据，那么得到的结果如下所示：
{ &amp;#34;Item&amp;#34;: { &amp;#34;Name&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;Alex DeBrie&amp;#34; }, &amp;#34;Age&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;29&amp;#34; }, &amp;#34;Roles&amp;#34;: { &amp;#34;L&amp;#34;: [&amp;#34;Admin&amp;#34;, &amp;#34;User&amp;#34;] } } }  需要注意的是：Age属性的值&amp;quot;29&amp;quot;是字符串，因此为了得到数值类型29，那么需要在应用程序里将字符串转成数值类型。
 对以上属性类型有一些基本了解之后，让我们来看看不同的属性类型。每种属性类型都会以类型标识（比如&amp;quot;S&amp;quot;代表string，而&amp;quot;N&amp;quot;代表number）和用例开始介绍。</description>
    </item>
    
    <item>
      <title>NoSQL的学习资料</title>
      <link>https://2cloudlab.com/nosql/additional-reading/</link>
      <pubDate>Thu, 21 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/additional-reading/</guid>
      <description>这篇文章收录了一些关于NoSQL的英文资料。有的解释NoSQL为何能规模化而SQL却受到限制；有的涉及NoSQL的单表设计原则，以及解释为何需要使用单表；其中有一篇文章是关于如何将SQL中多张有关联的表转化成DynamoDB中的单张表。还有一些关于DynamoDB的视频资料，其中的内容讲述了NoSQL的设计原则，以及如何高效使用DynamoDB。读者可以通过这些学习资料来掌握NoSQL的理论知识，通过这些知识来设计既能支持100TBs以上数据又能输出稳定性能的数据应用方案。
文章:  SQL, NoSQL, and Scale: How DynamoDB scales where relational databases don&#39;t - This is a post of mine explaining the core architectural decisions that allow NoSQL databases to scale further than their SQL brethren. The What, Why, and When of Single-Table Design with DynamoDB - A deep look at what it means to do single-table design in DynamoDB and why you would want to. It also includes a few situations where you may want to avoid single-table design.</description>
    </item>
    
    <item>
      <title>DynamoDB的环境搭建</title>
      <link>https://2cloudlab.com/nosql/environment-setup/</link>
      <pubDate>Wed, 13 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/environment-setup/</guid>
      <description>DynamoDB是一个完全托管于AWS的NoSQL解决方案。开发者可以选择直接在AWS上创建一个DynamoDB的表或者将DynamoDB安装到本地。后续的内容将涉及DynamoDB的API，比如通过AWS CLI来操作DynamoDB。为了操作DynamoDB，我们需要搭建DynamoDB的环境。
安装 AWS CLI AWS CLI是AWS提供的命令行工具，开发者通过使用这个工具能够方便地使用AWS所提供的云服务，包括DynamoDB服务。运行以下命令来安装AWS CLI：
$ pip install awscli 如果在安装过程种遇到困难，可以参考这里进行安装。
获取认证和授权 如果你打算使用AWS提供的DynamoDB服务，那么你需要正确地设置认证和授权的权限，具体需要参考官方文档。
比较简单的一种方式是授予开发者所有关于DynamoDB操作的权限，其策略定义如下：
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;dynamodb:*&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34; } ] } 一旦你在AWS上申请了一个账号并得到了能够操作DynamoDB的凭证，那么你还需要将这个凭证通过以下方式设置到本地电脑
$ aws configure AWS Access Key ID [None]: AKIAIOSFODNN7EXAMPLE AWS Secret Access Key [None]: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY Default region name [None]: us-west-2 Default output format [None]: json 在本地搭建DynamoDB服务 AWS提供了可在本地运行的DynamoDB，它可以在本地运行，免除了凭证的设置和避免了使用云端DynamoDB所产生的费用。
想要在本地使用DynamoDB，那么根据以下指令下载和安装DynamoDB：
$ curl -O https://s3-us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.zip $ unzip dynamodb_local_latest.zip $ rm dynamodb_local_latest.</description>
    </item>
    
    <item>
      <title>关于Dynamo的论文</title>
      <link>https://2cloudlab.com/nosql/the-dynamo-paper/</link>
      <pubDate>Tue, 12 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/the-dynamo-paper/</guid>
      <description>在2004这一年，Amazon.com的增长速度很快，最终其Oracle上的数据规模达到极限，限制了其业务的发展。为了摆脱这种限制，Amazon开始考虑建立他们自己的数据库（注意：在公司内部搭建一个数据库系统是非常糟糕的想法）。在研发自家的数据库之后，亚马逊的工程师创建了创造了Amazon Dynamo数据库，这个数据库支撑了大部分Amazon.com业务，包括其购物车。
那些研发Amazon Dynamo数据库背后的工程师于2007年发布了关于Dynamo的论文。这篇论文描述了这群工程师在搭建高可用，key-value存储过程中为了满足Amazon.com业务场景所学到的经验。
这篇论文影响深远，并催生一大批NoSQL的解决方案，这些解决方案包括Apache Cassandra(最初由Facebook研发)和AWS提供的 SimpleDB以及DynamoDB（注意AWS团队和Amazon团队是2拨不同的团队，2者互不关联）。2012年，Amazon Web Services对外发布了DynamoDB，该服务借鉴了Dynamo的经验和原则，且完全托管在AWS上。
 想要了解为何DynamoDB存储100 TBs以上的数据，却依然能保持稳定的性能? 请参考这篇文章 SQL, NoSQL, and Scale: How DynamoDB scales where relational databases don&#39;t。
 Dynamo的几个关键点 非关系型数据模型
关系型数据模型可以用来为不同类型的数据建模（比如针对一个电商的用户和订单来建模）。通常，使用关系型数据建模的方式为数据建模，需要将关联的数据拆分成更小的数据单元，以便这些数据是不重复的，这就是关系型数据库中著名的第一范式。其做法是，如果某类实体数据想要使用另外一类实体数据（比如将订单和用户关联），那么只需要将2类不同的实体数据存储在不同的表格，然后通过外键的方式来关联这2类数据以及通过JOIN操作来拼接和获取这2类数据。此时，你只需要修改某个实体（比如某个用户的用户名），那么另一个数据实体（比如订单所属的用户名也发生了变化）所引用的数据也会因此而变化。
然而，Amazon.com工程师在收集数据库需求时发现了一个非常有趣的结果：
 大约70%对数据库的操作是key-value类型，这些操作仅仅使用主键来获取单条数据。大约20%的操作会返回一个数据集，但是这些数据集均来自于同一张表。
&amp;ndash; Werner Vogels, A Decade of Dynamo
 以上发现是问题的关键 &amp;ndash; 90%的操作不会使用JOIN功能，而这一功能却是关系型数据库的核心。
JOIN操作非常消耗资源。当面对大规模的数据时，工程师通常会将数据复原为一个整体(拒绝使用第一范式)来避免使用JOIN操作而导致的高延时。 通过这种方式来降低响应延时的代价是增加了应用的复杂性&amp;ndash;此时应用程序需要考虑数据的完整性而不是数据库本身。
Amazon.com的工程师已经采用了以上方法来降低延时。实际上，正是意识到亚马逊工程师所需的并不是关系型数据模型，才使得Dynamo设计师重新评估关系型数据库的其它方面。
可用性比数据一致性更加重要
大部分关系型数据库使用strongly consistent model来操作数据。简而言之，这种模式会使得所有客户端在同一时间能够获得相同的数据(想想这个场景:一个用户正在写数据，而多个用户正在读这个写的数据)。
让我们通过Twitter作为例子. 假设2:30PM，Bob在Virginia 发布了一条关于猫的信息。在信息发布之后，有2个用户查看了Bob发布的信息，他们分别是他的邻居Cheryl和住在新加坡的叔叔Jeffrey。如果Twitter使用strongly-consistent model，Cheryl和Jeffrey会看到Bob发布的关于猫的信息。
用这种方式来确保看到一致的信息不是最理想的，原因有以下几点:
首先，考虑地理位置的因素。Twitter选择一台数据库服务来实施strong consistency。该数据库服务位于Virginia，离Bob和Cheryl很近。这使得该服务的响应很快能到达Bob和Cheryl，但是到达Jeffrey所需的时间就变长了，因为猫的信息会跨越大西洋从Virginia到Singapore。从地理上来分析，Bob和Cheryl获取猫的信息所花的时间显然会比Jeffrey所需的时间短。这种只选择一台数据库服务来实施strong consistency model的结果是，一些用户，像Jeffrey，获取信息的时间会变得漫长起来。那么有什么方式能让这些用户获取信息的时间缩短?
抛弃只有一台数据服务的做法，Twitter可以选择2台数据库服务，每台数据库服务上的数据是相同的&amp;ndash;其中一台放到Virginia另外一台放到Singapore。此时，如果我们依然需要实施strong consistency model， 那么就意味着同一个用户从以上2台数据库服务在同一时间获取同一份信息，其得到的数据是一样的。这也意味着Twitter需要在数据库服务上实现复杂的同步算法&amp;ndash;在Bob发布的关于猫的信息提交到数据库之前，这些信息必须成功地提交到这2台数据服务上。此时，Bob的提交将往返于整个大西洋，最终导致用户的写操作变得更慢。
在Dynamo paper中，Amazon指出strong consistency在其业务场景中并不重要。具体应用到我们的例子中的场景是:Jeffrey与Cheryl在同一时间将看到不同的版本的关于猫的信息。数据库服务可以使用eventual consistency model来同步数据。也就是说最终不同用户会看到相同的信息。Jeffrey最终会看到Bob发布的关于猫的信息，而这条信息于2:32 PM传送到Singapore，即便是这条信息于2:30 PM传送到Virginia。
Strong consistency model对于某些场景相当重要-比如银行账户中的余额-但对于某些场景并不重要，比如Twitter示例或者Amazon的购物车系统。 去掉strong consistency model的使用而换成eventual consistency model大大促进了Dynamo的发展。对于Twitter示例或者Amazon的购物车系统这类业务场景，速度和可用性比同时获取相同数据更加重要。通过减弱关系型数据库的consistency model，Dynamo的工程师能够研发更加适合Amazon.</description>
    </item>
    
    <item>
      <title>DynamoDB的关键概念</title>
      <link>https://2cloudlab.com/nosql/key-concepts/</link>
      <pubDate>Mon, 11 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/key-concepts/</guid>
      <description>在使用DynamoDB之前，我们需要了解一些基础概念，这些概念涉及了：表（tables），数据项（items）和每项数据的属性（attributes）、主键（primary keys），有简单主键（Partition Key）和复合主键（Partition Key + Sort Key）、附加索引（secondary indexes）、DynamoDB的读写能力。
本文将讨论关于DynamoDB的关键概念。完成这一章的学习之后，你将对以下概念有进一步的认识：
 表（tables），数据项（items）和每项数据的属性（attributes） 主键（primary keys），有简单主键（Partition Key）和复合主键（Partition Key + Sort Key） 附加索引（secondary indexes） DynamoDB的读写能力  表（tables），数据项（items）和每项数据的属性（attributes） 表（tables），数据项（items）和每项数据的属性（attributes）是DynamoDB的基础构建单元。
表是数据项的集合，不同类型的数据项都可以放到一张表里。例如：有一张Users表，该表存储了每一个用户的信息；有一张Orders表，该表存储了用户的所有订单信息。表的概念有点类似于关系型数据库中的表或MongoDB中的集合，与它们不同的是，DynamoDB中的表经常会存储不同类型的数据，比如用户信息以及该用户的所有订单信息会存储在同一张表中。
每条数据在表里就是一条记录（包含了多个属性（Attributes））。在表里，每条数据由主键（Primary Key）唯一确定。比如在Users表中，一条数据对应一个用户，这条数据包括了用户名，性别和住址等用户相关的信息。每条数据类似于关系型数据库表中的某一行或者MongoDB中的一个文档数据。
数据的属性组合成了每条数据，每条数据由多个数据属性构成。比如：一条用户数据包含了年龄属性，该属性存储了该用户的年龄。属性类似于关系型数据库表中的列或MongoDB中的属性。DynamoDB要求每一项数据都至少包含构成该数据主键的属性。
主键（Primary Key） 表中的每项数据由主键唯一标识。在创建表的时候，必须定义由哪些属性构成主键，当向表中新添数据的时候，该数据至少需要包含主键信息。
主键的类型有2类：简单主键和复合主键。前者仅由分区键（Partition Key）构成，而后者由分区键（Partiti Key）和排序键（Sort Key）组成。
简单主键类似于Memcached中的Key和SQL表中的主键。比如：用户名可以作为表Users的简单主键。
复合主键则更加复杂。你需要为表中的每一条数据提供分区键和排序键。排序键的作用在于使得同一分区的数据按照排序键的值进行排序。例如：某个用户的所有订单拥有相同的分区键（如：用户名），但每个订单的排序键（如：订单编号）是不相同的。
这里需要提醒的是：表中的每条数据是由主键唯一标识的。当使用复合主键来标识数据时，不同的数据可以拥有相同的分区键，此时，这些数据必须使用不同的排序键。由相同的分区键和不同的排序键构成的主键唯一标识了表中每一条数据。
复合主键可以支持复杂的数据查询模式。这些查询模式有：根据分区键来获取表中的数据；使用排序键来缩小查询范围。
读者可以根据拆解数据项来理解数据项的基本构成。
附加索引（Secondary Index） 主键唯一标识了表中的每一项数据，根据主键可以从表中获取到对应的数据项。然而有的时候，你需要根据其它模式来获取数据，比如你想查询订单金额超过某个范围的订单，而此时该表的Partition Key和Sort Key分别是用户名和订单号。使用该表的复合主键来满足这种查询显然是低效的，因此这个时候需要借助DynamoDB的附件索引来满足这一查询模式。附加索引有2种：local secondary index和global secondary index。
local secondary index使用了与表相同的分区键但是不同的排序键来构成索引。假设有一张Orders表，你想读取某个用户的所有订单，这些订单需要以订购数量（Amount）进行降序排序。此时，你只需要为Orders表创建一个local secondary index，该索引的分区键是用户ID（CustomerId），排序键是订单的订购数量（Amount）。开发者使用这个索引就能高效地获取某个用户的订单，并按照订单的数量进行排序。
global secondary index使用了与表完全不同的分区键和排序键来构成索引。你可以选择其它属性（不包含表的分区键）作为索引的分区键，从而构成该索引的简单主键，当然你也可以选择2个属性来构成索引的主键。假设有一张表，我们可以在这张表上定义一个global secondary index，该索引的分区键是订单号（OrderID），而排序键可以不设置，从而构成一个简单的主键。接着我们可以通过这个索引来根据订单号高效获取某个具体的订单，而无需通过查找用户和用户名下的订单这种低效的方式来查找。
附加索引是一个异常复杂的话题，但是这个功能却非常实用。它是实现不同查询模式的基础，想要深入了解和应用附件索引，读者可以前往这里。
读和写单元 当你使用MySQL，Postgres和MongoDB的时候，你需要启动一个服务器来运行这些数据库实例。你必须为这个服务器配置CPU，内存以及磁盘存储等。
而使用DynamoDB时，你不需要自己启动这些服务器，你只需要为创建的表指定读和写的单元，AWS就能自动地帮你启动服务器，并根据这些读写单元来启动服务器。这些读写单元限制了读写数据的吞吐量（KB/S），越多的读写单元其吞吐量会越大。与自己启动服务器来运行数据库实例的方式相比，这种方式的计费模式更加贴近真实的使用费用。
DynamoDB也能够自动增加和减少表的读写单元。这使得在数据使用的高峰期时，读写单元会自动增多，而在低峰期时，该读写单元会自动减少。通过这种根据实际使用情况来为表动态分配读写单元的方式能够减少支出。
下一步学习计划 如果你对DynamoDB的内部实现感兴趣，不妨去看看Dynamo Paper。如果不感兴趣，那么可以从搭建DynamoDB的环境开始，接着阅读对单条数据进行操作中的内容来理解数据的基本构成。
参考  原文链接  </description>
    </item>
    
    <item>
      <title>什么是DynamoDB？</title>
      <link>https://2cloudlab.com/nosql/what-is-dynamo-db/</link>
      <pubDate>Sun, 10 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/what-is-dynamo-db/</guid>
      <description>DynamoDB是一个由AWS提供的NoSQL数据库服务。它完全托管于AWS，开发者只需要定义数据访问模式以及一些关键信息，就能通过HTTP API来使用它。它具有以下特点：
 随着数据量的剧增，它依然能够提供稳定的性能输出 它完全由AWS管理。开发人员不需要SSH到其服务器，不需要管理服务器，不需在服务器上更新OS补丁和加密库等 它提供了简单的API，这些API能够对数据进行增删改查，除此之外，开发者也能根据获取数据的场景来定义查询模式  DynamoDB适用于以下场景：
需存储大量数据同时要求低延迟的应用服务。随着应用服务的数据量增多，JOINs和高级的SQL操作会大大降低关系型数据库的性能，从而导致应用服务的性能变差。如果使用DynamoDB, 对任何数据量（即使超过100 TBs）的查询操作，其延时也能够确定在某个具体的范围。
AWS Serverless服务。AWS Lambda服务提供了能自动弹性伸缩，无状态且短暂的计算能力。开发者只需要定义事件就能触发并应用这些计算能力。DynamoDB对外提供了HTTP API，开发者可以通过HTTP API来操作DynamoDB。开发者可以使用IAM roles来为DynamoDB进行认证(你是谁)和授权(你拥有哪些权限，比如读或者读写某张表)。这些特性使得DynamoDB特别适用于Serverless服务。
对数据具有确定且简单的访问模式(比如根据国家来获取所有星巴克的门店)。如果你编写了一个推荐系统，并根据用户的偏好来推荐物品，那么把DynamoDB作为数据基础，能够为推荐系统提供更快且性能稳定的key-value访问模式。
准备好学习更多关于DynamoDB的知识？ 这个系列的文章将以一些关键的概念开始，学习tables，items以及关于DynamoDB的其它组成部分。如果你急于了解DynamoDB背后所应用的计算机科学理论，那么可以参考Dynamo Paper。
如果你只是想动手练练，那么可以从准备环境以及对单条数据进行操作开始。紧接着，你可以通过学习对多条数据进行操作来掌握DynamoDB的Queries和Scans功能。
以上只是一些基础知识，想要了解更多的高阶知识，可以参考secondary indexes和DynamoDB Streams。
如果想要获得更多关于DynamoDB的学习资料，那么这里将是一个不错的地方。
 原文链接  </description>
    </item>
    
  </channel>
</rss>