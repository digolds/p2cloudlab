<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data-Intensive on 2cloudlab | 企业数字化转型的催化剂</title>
    <link>https://2cloudlab.com/tags/data-intensive/</link>
    <description>Recent content in Data-Intensive on 2cloudlab | 企业数字化转型的催化剂</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 Apr 2020 12:27:38 +0600</lastBuildDate>
    
	<atom:link href="https://2cloudlab.com/tags/data-intensive/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DynamoDB的学习指南</title>
      <link>https://2cloudlab.com/nosql/nosql-index/</link>
      <pubDate>Wed, 15 Apr 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/nosql-index/</guid>
      <description>如果你在软件行业（尤其是后端服务的研发）里从业几年，你肯定会听说过与存储和处理数据相关的几个时髦的技术词：NoSQL，大数据，云计算，ServerLess，ACID，CAP，分布式等等。驱动这些技术发展的原因是多样的，主要有以下几点：
 互联网巨头（比如Google，Microsoft，Amazon，Facebook，LinkedIn，Netflix以及Twitter）需要面对体量庞大的数据和流量，这迫使它们创造新的工具来高效处理海量数据 需要更短的研发周期和更灵活的数据模型支撑更加敏捷，更加容易测试和及时响应市场的业务场景 开源软件的发展变得更加成熟，而且与商业软件相比，提供了更好的功能 CPU的时钟频率很难提高，多核CPU已经逐渐成为标准，网络变得更快了（从原来的2G转变成为4G，到现在的5G）。这意味着并行计算的能力将会增强 得益于云计算服务的出现，即使你在一个小团队，也能打造一个分布式系统，甚至在不同的地理位置的不同机器上运行这套系统 许多数字化服务会一直处于7*24小时可用的状态，短暂的停机是无法接受的（比如Amazon短暂地停机会导致其商品买卖交易活动停滞，并引起经济损失）  因此，过去10年，为了应对大规模数据所带来的挑战，相应的工具和技术相继被提出。其中新型数据库系统（&amp;quot;NoSQL&amp;quot;）受到了很多关注，但是消息队列（message queues），缓存（caches），搜索引擎，数据流处理框架（Kafka和Samza）和其它分布式技术也相当重要！一个成熟的分布式系统一般会同时应用这些技术和工具。
以上提到的技术和工具都有对应的书籍介绍，而这个系列的文章（其列表如下）将聚焦在NoSQL数据库上，特别是AWS提供的DynamoDB。对于想要从事数据服务研发的工程师们，掌握NoSQL技能是必备的，因为它能够存储大规模数据（超过100TBs）的同时提供稳定的性能（数据操作的时间低于1ms），而要想在SQL数据库中拥有同样的能力，则需要付出巨大的代价，有时甚至无法实现！
NoSQL类型的数据库有很多，包括MongoDB，CouchDB和DynamoDB等。之所以使用DynamoDB的原因之一是它完全托管于AWS，开发者无需准备运行它的机器就能直接创建表。除此之外，DynamoDB还提供了永久的免费套餐。你想成为操作大规模数据的大师吗？如果答案是：Yes，那么你可以使用DynamoDB，并根据以下文章来实现这个目标！
介绍  1.1 什么是DynamoDB？ 1.2 DynamoDB的关键概念 1.3 关于Dynamo的论文 1.4 DynamoDB的环境搭建  单项数据操作  2.1 DynamoDB中，每项数据（item）的构成单元 2.2 在DynamoDB中插入和读取数据项 2.3 基础表达式 2.4 更新和删除数据项  多项数据操作  3.1 同时处理多项数据 3.2 查询 3.3 遍历 3.4 过滤  高级功能  4.1 附加索引 4.2 本地附加索引 4.3 全局附加索引 4.4 DynamoDB流  运维相关  5.1 Provisioning tables 5.2 安全 5.3 备份和恢复 5.4 自动伸缩 5.5 Global Tables  数据建模案例  6.</description>
    </item>
    
    <item>
      <title>如何正确使用DynamoDB</title>
      <link>https://2cloudlab.com/nosql/how-to-use-dynamodb-effectively/</link>
      <pubDate>Sun, 15 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/how-to-use-dynamodb-effectively/</guid>
      <description>把DynamoDB作为数据层的引擎能带来许多好处，一方面，它能够存储大规模数据的同时也保持高性能的数据存取，另外一方面，它能减少运维工作。打造一个稳定高效的数据服务需要解决很多问题，这些问题有：选择哪些工具为DynamoDB建模？如何记录热数据以及引发异常的数据？如何保证数据是加密存储在磁盘的？如何减少存取数据的响应延时？限制哪些用户拥有哪些数据存取的权限？选择哪种类型的数据备份策略？如何将数据发布到全球并保持同步？DynamoDB的最佳设计原则有哪些？等等。
 使用频率很高的数据被称为热数据。比如DynamoDB中的某项数据item每秒被访问1亿次，那么这个item就是一项热数据。
 以上问题有的一开始就会遇到（比如选择数据建模工具），有的则只在业务发展到一定阶段才会遇到（比如将企业的业务从中国区扩展到北美区）。不同问题需要不同的工具或者服务来解决，使用DynamoDB服务的一个好处是：它集成了很多开箱即用的服务。作为开发者，只需要创建这些服务，然后将其串联在一起形成一个完整的数据服务，而无需从头开始搭建解决问题的方案。
1.1 使用DynamoDB时需要考虑的问题 围绕DynamoDB展开研发数据服务需要在不同阶段考虑不同问题。这些问题将在研发所处的阶段一一暴露出来，而企业发展到一定阶段时才需要考虑属于这个阶段的问题。这3个阶段分别是：研发初期，测试阶段和发布阶段。其中发布阶段需要考虑的问题有很多。
在研发初期，需要为团队选择可视化工具来提供数据建模，可视化数据，以及操作数据。除此之外，还需要在本地安装DynamoDB，以便研发人员能够快速地在本地验证其想法。
在测试阶段，则需要搭建线上的测试环境，准备测试数据，使用AWS的Lambda服务进行各种测试（功能测试和性能测试）。由于测试环境位于AWS的数据中心，因此还需要考虑由哪些研发人员使用测试环境，以及他们所拥有的权限，这就是用户权限的问题。
在发布阶段，则需要准备生产环境，实施增量发布策略，在这个过程中还需要考虑如何在保持已有数据库服务稳定运行的同时升级数据库，升级业务逻辑，最终将数据服务平稳地替换成新的数据库服务而不影响线上用户，这就是我们常说的rolling deployment。由于数据是存储于云端的，因此为了数据安全，则需要为存储在云端的数据进行加密存储以及需要确保数据传输过程也是加密的。为了观察业务增长模式以及性能调优，则需要监控DynamoDB的使用情况，找出哪些数据经常被访问，哪个时间段的数据存储活动最活跃。为了防止运维人员错误地删除数据，则还需要选择合适的策略为数据进行备份。为了防止其他用户读取不相干的信息，则还需要考虑设置数据存取权限，以便某些数据无法被查阅。当遇到某些场景，其要求低延时，比如1微秒以内，那么则还需要考虑使用缓存技术来降低响应延时。当企业开始向海外扩张时，为了让海外用户能够快速地访问数据服务，则需要将数据完整地拷贝到离海外用户地理位置更近的数据中心。有时，你还需要将数据导出到数据分析系统，以便其它部门，比如销售或市场部门能分析这些数据，用于后续的营销活动。
企业的业务在发展过程中会经常遇到以上所提到的问题，为了解决这些问题则需要借助对应的工具。接下来，让我们看看DynamoDB都提供了哪些功能以及集成了哪些服务来解决上述提到的问题。
1.2 DynamoDB与周围的工具 DynamoDB本身提供了数据存取功能，它还考虑了高可用性（所有的数据会自动拷贝到不同的可用区，以免某一个区发生故障了，另外一个区能够及时补上），除此之外，它会将所有数据以加密的方式存储在磁盘（从9.KMS中获取秘钥），而传输过程中则使用了HTTPS协议来加密传输数据。DynamoDB还提供了1.Stream功能，该功能能够捕获数据的变动，因此可以基于这个功能将数据同步到4.其它数据分析系统。如果企业需要海外扩张，那么可以借助DynamoDB的2.Global Table功能。为了避免人为因素引起数据丢失，DynamoDB提供了2种数据备份的方式：分别是按需备份和按时间备份。这些功能均是开箱即用的，也就是说研发人员只需要根据实际的业务场景来组合所需的功能。之前所提到的部分问题均可以迎刃而解！而剩下的一些问题则需要结合一些周围的工具来解决。
使用DynamoDB的初期需要选择合适的数据建模工具：NoSQL Workbench。这个工具是一个可视化工具，有了它，研发人员可以通过可视化的方式数字化建模，定义数据存取模式，查看数据以及操作数据。通过这种方式，数据服务的设计者们可以很快地验证想法。
安装本地版本的DynamoDB对于研发人员来说是非常有必要的，原因在于它能够方便研发人员减少调试数据服务的时间。比如，你用Go语言编写了一个函数，该函数调用了GetItem接口，那么你可以在本地执行单元测试来验证这个函数是否达到预期。安装DynamoDB数据库的方式有很多种，其中通过Docker来启动DynamoDB是一个不错的方法，你要做的只需要安装Docker，之后运行以下指令，就能在本地使用DynamoDB。具体说明可以参考这里。
sudo docker run -p 8000:8000 amazon/dynamodb-local 为了对已有的数据服务调优，比如将经常被访问的数据放到缓存里，首先需要借助DynamoDB提供的10.Contributor Insights功能来查看哪些数据被频繁访问，哪些数据引发了错误，然后还需要启动3.DAX集群服务来缓存这部分数据。DAX集群与DynamoDB无缝连接，它将热数据放到DAX集群机器的内存里，最终从内存里取出数据提供给终端用户。
有时候，有些业务要求返回部分数据，比如对于线上机票业务，用户购买了一张机票，此时该用户只需要知道该机票的登机信息而不需要知道机长等信息。对于这种场景，则借助IAM服务来控制某些数据的访问权限（比如，创建5.Role）。再比如你的所有服务均部署在AWS，且你希望只有AWS中的服务才能访问DynamoDB，那么此时也可以借助IAM服务来支持这种场景。
使用DynamoDB的时候会产生各种信息，有些信息是指标数据：DynamoDB资源的使用情况，有多少请求因为资源不足而无法处理，错误信息，为了得到这些信息，研发人员可以使用7.CloudWatch服务来收集它们。除此之外，还可以创建8.CloudWatch Alarms来判断指标是否超出了一个界限，如果超出则会自动触发一系列操作。还有一些信息是关于操作相关的信息：是谁在什么时间段使用了DynamoDB以及做了什么操作，为了收集这些信息，研发人员可以借助6.CloudTrail服务。
通过以上描述可知，只有将DynamoDB以及周围的服务或工具结合在一起才能打造出一个完整稳定的系统。作为研发者，则只需要根据自身的业务需求来选择是否启用某些服务，比如，如果你的业务不要求微秒级别的响应，那么则没有必要启动3.DAX服务；如果你的业务只是服务于中国的用户，那么2.Global Tables的功能则不需要开启。这里需要注意的是，每种服务的使用都会增加系统的复杂性和费用，因此使用AWS服务的首要原则是按需使用。
1.3 DynamoDB与所处的位置 由上图可知，DynamoDB与许多服务均有交互，如图中的2所示。终端用户（图中的users）通过手机客户端或浏览器访问间接访问DynamoDB，它一方面可以通过https协议来存取数据，另外一方面通过3.DAX来加快存取数据的流程。在存取数据的过程中均会受到5.role的限制，role是属于IAM的一个资源，开发者为其指定哪些人拥有哪些操作DynamoDB的权限以及能存取哪些数据。每次对DynamoDB进行操作，都会产生log信息，这些信息主要分为2类，一类是哪些人做了哪些操作，这些信息存储在6.CloudTrail中，另外一类是关于操作DynamoDB的数据信息，这些信息有哪些数据是热数据，并通过10.Contributor Insights发布到7.CloudWatch中。如果发布到7.CloudWatch中的数据有异常，则会通过8.CloudWatch Alarm发起邮件来通知研发者。如果需要分析DynamoDB中的数据，那么则需要借助1.DynamoDB Stream来将数据导出到4.分析系统，市场人员将通过这个分析系统来生产报告，用于后续的市场推广活动。为了对DynamoDB中的数据加密存储到磁盘，则需要借助9.KMS服务，由KMS提供秘钥原料，并生成key来对数据进行加密。
DynamoDB自身具有自动备份的功能以及同步到不同的区域。区域与区域之间是地理上相互隔离，并通过高速电缆连接起来的数据中心。每一个数据中心除了能防止单点故障（某个区域发生故障后，另外一个区域依然能正常运行）之外，还可以从地理位置上降低服务的响应延时（美国的用户只需要访问美国的Oregon数据中心，而日本的用户则只需要访问Tokyo数据中心）。
作为研发者，在使用AWS服务时，则需要考虑环境的问题。比如，哪些环境是提供给终端用户使用的，哪些环境用于内部测试。比如上图创建了2个账号，分别是security和prod account。其中prod account专门用于生产环境，该环境需要严格把控，尽可能让最少的研发人员操作这个环境，因此需要借助IAM服务来授予部分经验丰富的工程师，授予最少的操作prod account资源的权限。所有研发工作者应该在security account里有对应的IAM User，并通过security来操作prod account中的资源。这种方式确保了每一个环境均是隔离的，且研发工作者的研发账号都得以在security account中统一管理（这种方式称为Across Accounts）。
结论 这篇文章试图通过现实世界中遇到的问题来分析DynamoDB所提供的功能以及集成了哪些服务。这些问题有的一开始就会遇到（比如每名DynamoDB的研发工作者，均需要将在本地安装DynamoDB，以便能方便调试。），有的则是在业务发展的过程中陆续出现，而研发工作者要做的是根据业务场景开启对应的功能或使用集成的服务来解决所遇到的问题。为了你能更好地使用DynamoDB，你需要知道它所处的位置，提供了哪些功能以及其他服务是如何与它交互的。另外，在统一管理研发工作者的账号时，通常需要考虑多个AWS账号，这种方式的好处是能让账号与账号之间的资源是相互独立，以便减少研发人员因错误操作而导致所有环境无法使用的风险。</description>
    </item>
    
    <item>
      <title>由amazon.com背后的数据系统所引发的思考</title>
      <link>https://2cloudlab.com/nosql/amazon-back-end-data-system/</link>
      <pubDate>Sat, 14 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/amazon-back-end-data-system/</guid>
      <description>amazon.com是服务于全球的在线电商，用户在它的平台上购买一件商品所需的时间不超过10秒。它是如何陈列成千上万件商品的同时，依然输出稳定的数据存取性能，从而提升全球用户在购物过程中的体验？对于这个问题的思考，将加深我们对数据库系统的理解，进而设计出优良的数据服务！本文将从Amazon的分类商品和推荐商品问题开始，揭示其背后的数据中心及其构成。紧接着为遇到的问题进行数据建模并分别使用MySQL，MongoDB，DynamoDB技术方案来解决这些问题。每种技术方案都有其适用的场景，并体现在文中，最终形成了一些判断依据，用于决定选择NoSQL还是SQL。
1.1 Amazon的分类商品与推荐商品所引发的思考 下图是从amazon.com首页截取的部分信息，主要包括 分类商品 与 推荐商品 。
图 1.1 amazon.com主页中部分商品
以上信息有一个特点：每一个大类中均包含多件商品。比如：推荐板块中列举了多件商品；Ride electric类目下有多种商品。这些信息通常会存储在中心服务器上，由数据库系统管理。当用户访问amazon.com时，浏览器会向中心服务器获取商品数据。整个过程如下图所示：
图 1.2 从数据中心查询商品数据
通过上图可知，数据中心不仅需要存储这些商品信息以及每件商品所属的分类信息，还要提供获取商品信息的方法。为了使数据中心具有数据存取的能力，往往需要引入数据库系统（下图蓝色区域部分）。这些系统不仅能够存储数据，也能够查询数据，通常运行于多台服务器。而这些服务器通过网线连接在一起，作为一个整体对外提供数据存取服务。最终，数据中心的演化如下图所示：
图 1.3 位于数据中心的数据库系统
注意：以上只是一个简化版的数据中心，现实情况是：amazon.com依赖于多个数据中心，每个国家都会有一个或多个数据中心（比如：美国，欧洲以及中国均有多个数据中心），每个数据中心都有大量的微服务支持着amazon.com。不同国家的用户会直接访问该国家的数据中心，这么做的好处是基于地理位置来降低访问延时。以上简化版的数据中心已经足够让我们讨论大多数amazon.com背后的数据服务了，对于业务遍布全球的企业，多数据中心是必须考虑的。接下来，让我们思考：使用数据库系统存取这些商品信息时会遇到的问题。
首先将遇到问题是：当数据量增多，超过现有的存储能力时，数据如何存储？通常的做法是增加存储空间，比如在每台服务器上挂载多块硬盘。
其次，当每秒访问数据库系统的次数增多时，如何确保数据库系统是有能力提供服务的？解决这个问题的做法是提供多台服务器（每台服务器中运行着数据库软件），并将数据切分成好几份，再将每一份分配到不同的服务器上。
最后，如何确保一次性获取完整的数据（比如一次性获取Ride electric类目下的多种商品）？当所有商品的数据集被切割成更小的集合散落在不同的服务器上时，会出现一种情况：相关联的数据分布在不同的服务器上，为了获取这些数据，则需要从不同的服务器中收集这些数据，最终整合在一起。这种方式存在一个问题：获取相关联的数据所需的时间变长了！因此为了减少获取数据的时间，则需要将相关联的数据集中在一台服务器上，以便一次性将这些关联的数据从一台服务器上取出，而不是多台服务器。为了实现这一目标，则需要一些数据应用的设计经验。
除了以上提到的问题之外，还有其它一些常见的问题需要考虑：如何确保每个分区的数据有多个备份（replica），以便该分区无法提供服务时，另外一个备份接替它的工作？如何解决数据热区的问题（比如一个热销商品被全球60亿人在一秒之内查看）？启动多少台数据库服务器以及如何监控这些服务器的运行状态？如何备份数据，以防人为失误所导致的损失（比如删除所有数据）？如何确保数据中心的温度是正常的，以便服务器能够正常运行？等等。虽然企业在起步阶段不会遇到这些问题，但是随着业务的增长，这些问题将会接踵而至，等待你的是无穷无尽的问题。
如果你开始着手处理以上所有提到的问题，那么你会发现：需要大量有经验的人才和时间以及金钱才能完成，而这种做法是非常糟糕的！好在，现有的云服务厂商，比如中国的阿里云，美国的AWS，Google Cloud以及Azure基本上解决了以上大多数问题！而我们只需要在其基础之上解决一些与业务相关以及技术选型的问题。接下来，让我们基于以上例子来分析有哪些业务问题需要解决，然后选择合适的技术来解决这些问题。
1.2 面临的问题 摆在我们面前的问题有以下2点：
 作为用户，我希望系统能根据历史购买记录来向我展示推荐商品的列表，时间控制在1s以内 作为用户，我希望系统为商品分类，并展示分类商品，时间控制在1s以内  以上问题有很多，分为前端和后端以及数据端，这里要讨论的焦点主要集中在 数据端。为了解决以上2个问题，我们需要对其进行数据建模-数据建模是指将现实世界中的问题抽象成数据实体（data entity）并建立数据实体之间的关系，最终通过计算机来表示。
通过问题的描述可知，共有4个数据实体，它们分别是：用户（User），商品（Product），推荐物（Recommend）以及商品分类（Category），以及3个关系，它们分别是：用户与推荐商品的关系，推荐物与商品的关系和商品分类与商品的关系。整个数据实体以及其之间的关系可以通过下图抽象出来：
图 1.4 基于SQL的Schema来数据建模
上图实体之间的连线代表它们之间的关系，其中1:*的含义是只1对0或1对多。比如一个用户可以有0，1，或者多个推荐商品。
对面临的问题建立数据模型之后，接下来需要考虑的问题是：技术选型。
1.3 技术选型 在软件行业里，专门针对数据存储与查询的数据库系统有很多，主要分为2大阵营，它们分别是SQL和NoSQL。典型的SQL产品有：MySQL，SQL Server，PostgreSQL等等，而NoSQL的产品有：MongoDB，CouchDB，Dynamo，DynamoDB等等。每种类型的数据库都有其适用的场景，没有一个数据库能够解决所有问题，常见的做法是将这些数据库整合在一起来提供一套数据库系统解决方案。比如SQL数据库产品就特别适合OLAP类型（数据分析）的业务，而NoSQL则适合于OLTP类型（线上交易或即时交互）的业务。比如amazon.com的后台数据系统的构成主要分为3大部分，它们分别是：
 由NoSQL数据库系统组成，并提供在线交易支持的数据服务 由SQL数据库系统组成，并为公司内部提供数据分析服务（ETL） 大数据平台，比如由Hadoop，Spark等框架提供的大数据服务  我们所面临的业务问题属于OLTP类型，因此接下来的内容将围绕OLTP类型的业务问题展开。在展开过程中，我们首先考虑使用SQL数据库系统来解决问题，然后分析这种方法能够带来哪些好处以及什么时候能使用它。除此之外，我们也会分析使用这种方法在哪些条件下会遇到瓶颈以及如何使用NoSQL来解决所遇到的问题。其次，我们会分析NoSQL是如何消除这些瓶颈以及需要为之付出的代价。最后，我们将解释为什么使用DynamoDB而不是其它NoSQL数据库系统。以上提出的第2，3点虽然不属于本文讨论的范围，但是它们在现代互联网企业中依旧占有一席之地，只不过这些问题会随着企业的发展而渐渐浮出水面！
 OLTP=(Online transaction processing)，是指线上交易活动的处理，比如电商，社交网络，搜索引擎等属于这类问题。这类活动有一个特征：低延时。
OLAP=(Online analytical processing)，是指线上分析的处理，比如BI系统，市场分析，销售报告等与数据分析与挖掘相关的日常问题均属于这类问题。这类活动有一个特征：在海量数据里读取一小部分数据来生成报告，进而分析业务活动。
 首先，让我们看看 使用SQL数据库系统 解决之前所提到的2个业务问题的情况。成熟的SQL数据库系统有很多，这里我们选用MySQL来解决以上提出的问题。接下来提到的方法同样适用于其它数据库系统。使用MySQL的前提条件是创建Schema，如图 1.4所示。该Schema里包含了4张表，每张表对应现实问题中的一个数据实体，比如&amp;quot;users&amp;quot;表代表用户实体，表中的每一行代表一个具体的用户，该表能容纳多个不同的用户。
为了处理获取某个用户的推荐列表的请求，MySQL数据库需要执行以下步骤：
 从表&amp;quot;users&amp;quot;中找到该用户所对应的行，拿到user_id 根据user_id到表&amp;quot;recommends&amp;quot;中找到所有与user_id相等的行 遍历步骤2返回的结果，根据每一行数据中的product_id从表&amp;quot;products&amp;quot;中取出详细的商品信息 将1，2，3步获得的数据打包成一个整体返回给请求端（比如浏览器）  为了处理获取分类商品的请求，MySQL数据库需要执行以下步骤：</description>
    </item>
    
    <item>
      <title>如何在DynamoDB中实现排名榜</title>
      <link>https://2cloudlab.com/nosql/leaderboard-write-sharding/</link>
      <pubDate>Fri, 13 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/leaderboard-write-sharding/</guid>
      <description>在互联网的世界里，你通常会看到一些Top 10事件，比如微博里的Top 10热点事件，领英每年发布的某个行业里最具影响力的Top 20行家，一个图片网站里最受欢迎的Top 100图片等等。你不仅能看到Top 10事件，还会购买一些Top 10热销产品，比如说一些电商网站上好评前10的产品，购买量Top 10的产品等。这些事件或商品有一个特征：Top 10。那么如何利用DynamoDB为这类数据建模呢？如何在海量的事件或者商品里快速找到Top 10的事件或商品呢？这些问题的答案将在下文给出！
本文将介绍如何为DynamoDB中的数据集建立和维护一个积分榜。正如前面所提到的，许多应用场景会使用到积分榜。假设，有一个数据集，你不仅想获取这个数据集中的某项数据，还想根据某个属性获取Top N项数据。
文中的示例是一个图片服务，存储了大量图片&amp;ndash;类似于Unsplash服务。除了要获取单张图片的详细信息，我们还想查看点击数前几的图片。
在整个过程中，你将学到如何将write sharding结合scatter-gather在一起实现这种积分榜。
我想脱帽致敬Chris Shenton，起初是他和我讨论了这种实现积分榜的方法。AWS也在其官方文档里提供了一个在游戏行业中使用积分榜的例子。然而，该例子只针对多个游戏使用了多个积分榜，而不是一个积分榜记录了多个游戏。</description>
    </item>
    
    <item>
      <title>如何在DynamoDB中查询层级结构的数据</title>
      <link>https://2cloudlab.com/nosql/hierarchical-data/</link>
      <pubDate>Thu, 12 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/hierarchical-data/</guid>
      <description>在本文的示例中，我们将展示如何在DynamoDB中建立具有层级结构的数据（比如树状结构）。这个例子使用了大约25000个星巴克实体店的地址信息。你可以到这里获取源码来动手实践本文所提到的步骤。
层级结构的数据经常在关系型数据库中使用，将数据以树状结构来表示，比如组织架构图或族谱就是这种类型的数据。在关系型数据库中，为了将这些层级结构的数据连接在一起，通常需要使用多个JOINs来完成。而在本文中，我们仅使用一张DynamoDB的表来建立这种数据结构，并提供了更快的查询性能。
 这个例子的灵感来自于Rick Houlihan在2017年的AWS reInvent上的研讨会，感兴趣的读者可以到这里一睹其风采。
 一些关于本文示例的基本信息 假设，我们是星巴克，一家跨国公司，门店遍布全球。现在，我们想把全球所有门店的信息存储在DynamoDB中，并希望能够快速查询以下信息：
 根据门店编号来获取对应的门店信息 列举属于某个国家的所有门店信息 列举一个州或一个省下的所有门店信息 列举一个城市中所有门店信息 列举一个区里所有门店信息  第一种查询模式比较简单&amp;ndash;就是那种key:value的关系，只需要给出门店编号，那么就能取到该门店的信息。剩余的4种查询模式就不是那么容易实现了。 当然，你可以创建4个全局附加索引来分别支持这4种查询模式，也可以使用Filter表达式来过滤出我们想要的数据，但是这2种方法并不高效，同时会消耗更多的读取能力，进而增加费用。
为了解决以上提出的2个问题，我们可以借助该数据的层级信息以及仅使用一个全局附加索引来实现以上4种查询模式！接下来，让我们到Kaggle获取遍布全球的星巴克门店数据&amp;ndash;大约25000条。获取之后需要将这些数据写入到我们的表中，并验证是否完全倒入！以下提到的代码片段摘自这里。
准备工作 为了运行以下示例，你需要下载之前提到的数据，并解压它，然后将CVS文件复制到你的工作目录，名称是directory.csv。除此之外，你还要安装Python以及Boto3框架，该框架是Python版本的AWS SDK。你可以运行指令pip install boto3来按照该框架。最后，有些例子使用了Click框架，该框架能够帮助你快速制定命令行接口，运行指令pip install click来安装它。
设计主键和插入数据 一切就绪之后，是时候创建表以及将数据插入到表中。
首先，为表选择合适的主键。主键应该至少体现以下2点：
 它具有唯一性。也就是它能唯一识别每项数据 它具有均匀分布的特性  理想状态下，主键也需要满足至少一条查询模式。
对于我们要处理的问题，将Store Number作为表的简单主键将是不错的选择。如果我们想要更新某个店铺的信息，那么肯定需要提供该店的Store Number。这符合查询模式的第一项：根据门店编号来获取对应的门店信息。除此之外，Store Number是均匀分布的。
接着，我们需要考虑其余4种查询数据的模式&amp;ndash;如何根据国家，州，城市，区号来获取对应的实体店信息？我们将很快在后面的内容中讨论这个问题，但是现在，我们只需要创建一个全局附加索引&amp;quot;StoreLocationIndex&amp;rdquo;，这些索引需要满足以下要求：
 将Country作为分区键（HASH key），用于指定实体店所在的国家 排序键（RANGE key）为StateCityPostcode，它是一个由State, City和Postcode构成的字符串，其格式为##。例如：一家位于Omaha，NE的店铺，该值应该是：NE#OMAHA#68144。  为了创建这个表，则需要运行以下脚本文件。如果执行成功，则会输出以下信息：
$ python create_table.py Table created successfully! 接下来，将directory.csv文件中的数据加载到DynamoDB中。脚本文件insert_items.py将读取这个文件的数据，然后遍历所有数据项，并将每一项数据插入到DynamoDB中。注意：整个过程需要一些时间，因为大约有25000项数据。
$ python insert_items.py 1000 locations written... 2000 locations written... ... &amp;lt;snip&amp;gt; ... 24000 locations written... 25000 locations written.</description>
    </item>
    
    <item>
      <title>DynamoDB Stream</title>
      <link>https://2cloudlab.com/nosql/dynamodb-streams/</link>
      <pubDate>Thu, 05 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/dynamodb-streams/</guid>
      <description>DynamoDB的表能够存储大量的数据，为了提高查找性能，研发人员通常会将关联但不同的数据实体（比如User和Order）集中存放在一台服务器上，这就导致表中的数据关系难以理解！如果直接基于该表来分析其中的数据，则分析工作将会变得困难起来，除此之外，也会影响终端用户的用户体验（分析任务会占用该表的读写单元）。为了使分析工作变得简单，则需要将表中的数据导入到其它分析系统，最终依赖其它分析系统来分析数据。将数据导出到其它系统主要有2种办法，它们分别是：1.遍历整张表，并将每一项数据写入到其它系统；2.表中的数据每变更一次，则将变更写入到其它系统。前者不适用于数据量庞大的情景，而后者可以很好地避开处理大量数据，但需要借助DynamoDB Stream功能来实现。
DynamoDB Stream是DynamoDB提供的一个功能，现实世界里有许多场景会使用到它，这些场景有：
 同步不同区域的数据。比如你的业务分布在中国和美国，那么你需要将美国的数据同步到中国，反之亦然。此时你需要借助DynamoDB Stream来实现数据同步，最终确保中国用户与美国用户访问的数据是一致的。 发送消息。比如你的App有一个用户注册功能，每当一个新用户注册时，你需要向新用户发送一封表示欢迎的邮件通知。此时你需要DynamoDB Stream的通知机制来触发分发邮件的服务。 索引数据。DynamoDB不适合全文搜索，因此如果你想要搜索表中的数据，那么最好的办法是将表中的数据快速同步到Elastic Search服务或者algolia里，最终通过这些服务来搜索数据。为了能够快速地将数据更新到搜索系统，那么则需要DynamoDB Stream。 聚合或统计数据。有时你想快速得到一些统计信息，比如某个区域的总销量，每家门店每个月所需的成本等等。那么你可以使用DynamoDB Stream来聚合这些数据。  为了实现以上提到的应用场景，则需要了解DynamoDB Stream内部的逻辑以及它与其它服务的关系。这篇文章将从以下几个方面来讲解DynamoDB Stream：
 DynamoDB Stream的构成以及其周边服务 使用DynamoDB Stream的注意事项 基于DynamoDB Stream的设计模式 参考  DynamoDB Stream的构成以及其周边服务 DynamoDB Stream是DynamoDB服务所提供的一个功能，它需要结合DynamoDB Table来使用。开启DynamoDB Stream功能的Table能集成其它服务，最终能够延伸DynamoDB的功能（比如，使用Elastic Search来检索表中的数据，并提供全文搜索功能！）。下图展示了DynamoDB Stream与其它服务的关系：
上图涉及到DynamoDB Stream的工作流程是：
 Producers将向表中修改数据，包括添加数据，修改已有数据，删除数据等。这些操作均是基于HTTPS协议来发起的。 DynamoDB将修改之后的数据写入内部的Transactions Log文件，DynamoDB Stream从该文件中读取更新之后的数据并存放24小时，在这之后，数据将自动从DynamoDB Stream中移除。 Lambda平台向每一个Shard发送HTTPS请求并以poll的方式监听所有的Shards。 Lambda平台从Shard中批量读取新数据（Records），并以Sync的方式启动一个Lambda Function实例，并将Records传入并执行该实例。如果结果返回成功，那么Lambda平台会继续读取下一批数据，失败则把当前的数据集传入该函数实例，并重新执行。  上图涉及到DynamoDB Stream的内部逻辑以及外部交互：
研发人员在使用DynamoDB服务时，需要创建表（Table），每一张表其内部又根据数据量划分了好几个分区（如上图的Partition A，Partition B，Partition C）。每一个分区其实会分布于不同的服务器上。
如果在该表上启用了DynamoDB Stream，那么这个Stream会根据分区数量来创建Shard（如上图有3个Shard）。每一个分区中修改的数据只会发送到对应的Shard上，并且是有序的。每一个Shard里的数据（如上图的Record），其生命周期是24小时，在这之后，该数据项自动移除。
DynamoDB Stream只允许使用者（也就是上图的Consumers）从中批量读取数据，其它操作，比如删除其中的数据项或者修改其中的数据项是禁止的。DynamoDB Stream的吞吐量（MB/S）受到Shard的限制，Shard的数量越多，则其吞吐量越大（每个Shard的吞吐量是2MB/S，每个Consumer每秒最多能读取1MB的数据）。每个Consumer一次最多能从对应的Shard中读取1000条数据（Record）。每个Shard最多同时被2个Consumers来使用，超过这个数量，则会导致读取失败，这一点使得DynamoDB Stream无法直接支持超过2个以上的服务（比如，无法同时支持新用户注册收到欢迎邮件，将数据导出到其它分析系统，检索DynamoDB中的数据等）。
上图使用了AWS Lambda服务作为DynamoDB Stream的Consumers。研发人员只需要创建一个Lambda Function，然后将该Function的触发器设置成DynamoDB，就能接收DynamoDB Stream的通知了。当每个Shard里有新的数据时，Lambda服务会根据该函数的设置（比如最多一次取10000个Records）读取Records（如果Shard里有100万条数据，每1000条的数据量是0.8MB&amp;lt;1MB，那么Lambda服务会调用10次GetRecords操作，并得到8MB的数据，但是由于Lambda Function的request PayLoad最大是6MB，因此，此时调用Lambda Function时会引发异常。），然后调用Function实例，并将读取到的Records批量传递给Function，由Function决定发送给哪些下游服务，如果这些批量数据均处理成功，那么Lambda服务将继续从对应的Shard中读取下一批Record，直到对应的Shard中没有新的数据。
除了使用Lambda Function，还可以使用EC2，并运行KCL和DynamoDB Streams Kinesis Adapter应用来读取数据，如下图所示：</description>
    </item>
    
    <item>
      <title>DynamoDB的全局附加索引</title>
      <link>https://2cloudlab.com/nosql/global-secondary-indexes/</link>
      <pubDate>Wed, 04 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/global-secondary-indexes/</guid>
      <description>本文将介绍全局附加索引。与之前介绍本地附加索引的文章一样,我们将涉及全局附加索引的基础知识，然后通过一个例子来使用全局附加索引。
全局附加索引的基础知识 不像本地附加索引，你可以在具有简单主键或复合主键的表中添加全局附加索引。除此之外，你还可以创建具有简单主键的全局附加索引。
以下是列举了全局附加索引的不同之处：
 拥有属于自己的读写单元。当你创建全局附加索引时，你需要单独为该索引分配读写单元。这无疑会增加使用上的复杂程度以及更多的费用，但是同时也给你更加灵活的选择来处理不同模式的读写请求 Eventual consistency。向表中写入一项数据时，这项数据是以异步的方式同步到全局附加索引的。这意味着，当你同时向表和全局附加索引读取同一数据时，其返回结果可能会不一样。而且使用全局附加索引只能选择该选项来同步数据，而无法选择strong consistency来同步数据 同一全局附加索引的分区键能够容纳无限数据。而使用本地附加索引时，这一限制是10GB。 适用于任何表。本地附加索引只能用于具有复合主键的表，而全局附加索引没有这个限制&amp;ndash;你可以将其用于具有简单主键或复合主键的表 可以创建具有简单主键或者复合主键的全局附加索引。  创建全局附加索引 类似本地附加索引，你可以在创建表的时候创建全局附加索引。然而，你也可以在已有的表上创建全局附加索引。如果在已有的表上创建全局附加索引，那么DynamoDB将自动把表中的数据同步到全局附加索引中。
以下示例展示了如何使用全局附加索引建立稀疏索引。稀疏索引的用途是存放一小部分常用的数据，以便提高更快的查找效率！只有那些包含稀疏索引主键的数据才会被同步到稀疏索引中。
假设有一个场景：跟踪用户退货的订单。我们将在这些订单中添加属性ReturnDate，然后将该属性作为稀疏索引的分区键，OrderId属性作为稀疏索引的排序键。
以下创建了该稀疏索引：
$ aws dynamodb update-table \  --table-name UserOrdersTable \  --attribute-definitions &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;ReturnDate&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;OrderId&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; } ]&amp;#39; \  --global-secondary-index-updates &amp;#39;[ { &amp;#34;Create&amp;#34;: { &amp;#34;IndexName&amp;#34;: &amp;#34;ReturnDateOrderIdIndex&amp;#34;, &amp;#34;KeySchema&amp;#34;: [ { &amp;#34;AttributeName&amp;#34;: &amp;#34;ReturnDate&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;HASH&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;OrderId&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;RANGE&amp;#34; } ], &amp;#34;Projection&amp;#34;: { &amp;#34;ProjectionType&amp;#34;: &amp;#34;ALL&amp;#34; }, &amp;#34;ProvisionedThroughput&amp;#34;: { &amp;#34;ReadCapacityUnits&amp;#34;: 1, &amp;#34;WriteCapacityUnits&amp;#34;: 1 } } } ]&amp;#39; \  $LOCAL 创建全局附加索引的方式类似于本地附加索引。注意：我只需要在--attribute-definitions中添加全局附加索引的属性，以及使用--global-secondary-index-updates选项来指定分区键或排序键。</description>
    </item>
    
    <item>
      <title>DynamoDB的本地附加索引</title>
      <link>https://2cloudlab.com/nosql/local-secondary-indexes/</link>
      <pubDate>Tue, 03 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/local-secondary-indexes/</guid>
      <description>在之前的文章中，我们学习了附加索引的基础知识。在本文中，我们将深入到本地附加索引。首先，我们将涉及本地附加索引的基础，紧接着通过一个例子来使用本地附加索引。Let&#39;s Go!
本地附加索引的基础知识 请注意：你只能在具有复合主键的表中添加本地附加索引。本地附加索引的分区键必须和复合主键的分区键一样，然而允许指定不同的排序键。
一些关于本地附加索引的注意事项：
 本地附加索引的创建必须在创建表的时候添加。也就是说你无法在已经创建好的表上添加附加索引，而是在创建表的时候添加。这一点与全局附加索引不一样 拥有相同分区键，但不同排序键的数据量不允许超过10GB。注意这10GB数据包括表中的数据量加上本地附加索引中的数据量。如果你使用了本地附加索引，那么你得认真考虑使用映射表达式 Consistency选项。对于本地附加索引，你可以像表一样选择strong consistency或者eventual consistency。Strong consistency将占用更多的读单元，但是适用于某些场景 附加索引与表中的读写单元是共享的。也就是说向本地索引读写数据时，会占用表中的读写单元  创建本地附加索引 现在，让我们动手来实践本地附加索引。还记得创建本地附加索引需要在创建表的时候完成吗！因此之前创建的&amp;quot;Users&amp;quot;表不能使用本地附加索引，所以我们只能考虑在&amp;quot;UserOrdersTable&amp;quot;表中添加附加索引。
还记得之前那个根据订单额度来过滤某个用户订单的例子吗？由于订单额度不是主键的一部分，因此我们不得不先根据主键获取该用户的订单，然后再使用过滤表达式来过滤出超过某个额度的订单。
这种需要根据订单额度来过滤数据的模式对于数据量大的场景显然是不适用的&amp;ndash;原因在于，某个用户的订单有很多，比如上万条，而你只需要在这上万条数据中查找几条数据。为了解决这类问题，我们需要建立本地附加索引，并把订单额度作为该索引的排序键。这么一来，根据订单额度来查询订单数据就变快了许多。
虽然本地附加索引能解决以上问题，但不幸的是，创建附加索引必须在创建表的时候指定。不管如何，首先，让我们运行以下指令删除之前的表：
$ aws dynamodb delete-table \  --table-name UserOrdersTable \  $LOCAL 紧接着在创建带有本地附加索引的表：
$ aws dynamodb create-table \  --table-name UserOrdersTable \  --attribute-definitions &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;OrderId&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;Amount&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;N&amp;#34; } ]&amp;#39; \  --key-schema &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;HASH&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;OrderId&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;RANGE&amp;#34; } ]&amp;#39; \  --local-secondary-indexes &amp;#39;[ { &amp;#34;IndexName&amp;#34;: &amp;#34;UserAmountIndex&amp;#34;, &amp;#34;KeySchema&amp;#34;: [ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;HASH&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;Amount&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;RANGE&amp;#34; } ], &amp;#34;Projection&amp;#34;: { &amp;#34;ProjectionType&amp;#34;: &amp;#34;KEYS_ONLY&amp;#34; } } ]&amp;#39; \  --provisioned-throughput &amp;#39;{ &amp;#34;ReadCapacityUnits&amp;#34;: 1, &amp;#34;WriteCapacityUnits&amp;#34;: 1 }&amp;#39; \  $LOCAL 以上示例与CreateTable的命令一样。一开始，我们指定了表名，然后增加了2点：(1) 使&amp;quot;Amount&amp;quot;属性作为本地附加索引的排序键；(2) 使用--local-secondary-indexes选项。</description>
    </item>
    
    <item>
      <title>DynamoDB的附加索引</title>
      <link>https://2cloudlab.com/nosql/secondary-indexes/</link>
      <pubDate>Mon, 02 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/secondary-indexes/</guid>
      <description>到目前为止，大部分的读操作主要是基于表的主键来执行的，要么通过GetItem或者Query完成。使用表的主键来查找数据项是非常高效的一种做法，同时也避免了使用Scan来遍历整张表。
然而，使用主键会限制数据的查询模式。比如，在之前的查询示例中，我们将订单日期作为排序键，使得我们可以根据订单的日期来快速获取某个客户的所有订单。这就意味着我们无法根据订单量来快速获取某个客户的所有订单，因为订单量并不是主键属性。为了解决这个问题，我们可以使用Filter表达式来解决，但是这种办法并不高效，因为Filter是作用在返回的数据集上。那么有什么办法能让返回的数据集就是根据订单数量的大小来决定的？
幸运的是，DynamoDB有一个附加索引的功能，它允许开发者定义其它附加主键，而这些主键可以用于Query（查询）或Scan（遍历）操作。
本文将讨论2种类型的索引，以及使用附加索引的基本规则。
附加索引的类型有几种？ DynamoDB支持2类附加索引，它们分别是：本地索引（local secondary indexs）和全局索引（global secondary indexes）。
本地索引只能创建在具有复合主键的表之上，它的分区键与复合主键的分区键是一样的，但是却使用了不同的排序键。使用本地索引的一种场景是之前根据订单量来获取某客户的所有订单的示例。
全局索引能够创建与表的主键完全不一样的附加主键。比如：你可以在一张具有附加主键的表上使用全局索引来创建简单键，或者你也可以选择与主键完全不同的属性来创建附加的复合主键。当然，如果一张表只有一个简单主键，那么你依然可以使用全局索引来创建附加的复合主键。
附加索引是一个相当有用的功能，它能够衍生出更加高效且灵活的查询模式。
附加索引的基础知识 下面有一些关于附加索引的基础知识是需要知道的：
 附加索引可以不唯一。还记得吗？当我们插入数据时要求该数据的主键是必须唯一的，但是这一条限制不适用于附加索引。因此你可以创建2个具有相同附加索引的数据项（前提是其主键必须不一样）。 附加索引的不一定要提供。当向表中插入数据时，你必须指定主键，而可以不需要提供附加索引的信息&amp;ndash;如果你插入一项新的数据，该数据没有包含索引信息，那么该数据不会添加到索引里，这样的特性使索引变得更加稀疏，常常被称为稀疏索引。稀疏索引有其用武之地，比如建立一个索引搜集所有退货的商品。 每张表的索引数量是有限制的. 每张表最多能创建20个全局索引和5个本地索引  向附加索引中映射属性 当你创建附加索引的时候，你需要指定那些属性是需要映射到即将创建的附加索引。这么做的好处是：当一个基于附加索引的查询执行时，映射好的属性将直接返回，从而避免再次从主表中读取属性信息。
而映射的选项有：
 KEYS_ONLY: 仅映射表的主键信息，比如分区键和排序键以及对应的值 ALL: 将表中完整的数据项映射到该索引 INCLUDE: 选择若干属性映射到该索引  当你建立索引时，要结合查询模式来考虑。DynamoDB会根据索引所存储的数据量来收费，因此将完整的数据项映射将会使你的存储费用变成2倍。而另一方面，你还需要避免查询一次数据需要读取2次表格的情况（一次索引，另外一次是表）。
接下来，让我们进一步了解什么是本地索引。
 原文链接  </description>
    </item>
    
    <item>
      <title>在DynamoDB中使用Filter表达式</title>
      <link>https://2cloudlab.com/nosql/filtering/</link>
      <pubDate>Sun, 01 Mar 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/filtering/</guid>
      <description>在过去的几篇文章里，我们讨论了关键字表达式，条件表达式，映射表达式以及更新表达式。本文将讨论最后一类表达式&amp;ndash;过滤器表达式。
过滤器表达式用于Query和Scan操作，它在作用于这些操作所返回的数据集，并过滤出满足条件的数据项，进而返回给客户端。在深入了解Filter之前，我们有必要来了解一下Query或Scan底层的执行过程。
Query和Scan的执行过程 对于DynamoDB的Query和Scan操作，有3步是需要DynamoDB来完成的：
 从表中查找数据。对于这2类操作，查询将从Starting Token开始，如果在Query中提供了关键字表达式，那么查询的过程中将考虑这类关键字 （这一步是可选的），如果在查询（Query）或遍历（Query）的过程中使用了Filter，那么这个Filter将作用于第一步返回的数据集。同理，映射表达式也是在这一步作用于第一步返回的数据集。 把数据返回给客户端  有一点需要特别注意的是：DynamoDB对返回数据量的限制是由第一步来决定的。比如，如果你在第一步获取100KB的数据，而在第二步使用过滤器将数据量缩减到10KB，那么DynamoDB依然会按照100KB来计算其最终的返回数据量。还需要注意的是：DynamoDB中的任何操作其处理数据的量不能超过1MB，尽管你正在操作的表有充足的读单元。
过滤表达式和映射表达式不是一个高性能的利器-它们不会使你的查询效率变高，然而，它们能帮助你减少数据量，从而最终减少传输带宽的使用。不仅如此，你可以将这些过滤操作逻辑从业务层转移到数据库层。
 关于更多Filter以及什么时候使用它的知识可以参考这篇文章When to use (and when not to use) DynamoDB Filter Expressions。
 如何使用Filter Filter表达式与关键字表达式类似，都可以和Query操作配合&amp;ndash;你只需要在过滤表达式中指定想要过滤的属性，查询结果就会更具该表达式来过滤。
让我们基于之前Query来查找用户&amp;quot;daffyduck&amp;quot;的订单。这一次我们想依据订单额度来过滤数据，比如我们只想返回订单量超过100美元的订单，示例如下：
$ aws dynamodb query \  --table-name UserOrdersTable \  --key-condition-expression &amp;#34;Username = :username&amp;#34; \  --filter-expression &amp;#34;Amount &amp;gt; :amount&amp;#34; \  --expression-attribute-values &amp;#39;{ &amp;#34;:username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; }, &amp;#34;:amount&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;100&amp;#34; } }&amp;#39; \  $LOCAL 以下的返回结果只返回了一个订单：
{ &amp;#34;Count&amp;#34;: 1, &amp;#34;Items&amp;#34;: [ { &amp;#34;OrderId&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;20170609-25875&amp;#34; }, &amp;#34;Username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; }, &amp;#34;Amount&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;116.</description>
    </item>
    
    <item>
      <title>在DynamoDB中，谨慎使用Scans操作</title>
      <link>https://2cloudlab.com/nosql/scans/</link>
      <pubDate>Fri, 28 Feb 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/scans/</guid>
      <description>本文将介绍DynamoDB的Scans操作。该操作是DynamoDB的重型武器。做一个相似的对比: GetItem操作就是是一对镊子，可以夹出某个特定的物件。Query操作像把铁铲，能挖出一大堆物件，但是其作用的范围依旧很小。然而，Scan操作就像一辆拖拉机，把整个修整区域翻个底朝天。
在我们深入到Scan操作之前，请记住以下这句话:
 不要使用Scan操作，除非你知道自己在做什么。
 Scan操作作用于整张表。对数据量庞大的表，该操作将耗尽整张表的读取单元。如果你在应用程序里的关键路径里使用它，那么它会增加响应延时。
只有在以下情况下，才会考虑使用Scan操作:
 表的数据量不大 将数据迁移到另外一个数据库系统 you use global secondary indexes in a special way to set up a work queue (very advanced).  带着以上告诫，让我们来探索Scan操作的使用方式。
Scan操作的基础知识 Scan操作是DynamoDB中最容易使用的功能。开发者只需要在执行该操作时提供表的名字，它就能帮你返回表格中所有数据项（返回的数据量不超过1MB）：
$ aws dynamodb scan \  --table-name UserOrdersTable \  $LOCAL 以下是返回结果（为了方便阅读，其中省略了中间部分）：
{ &amp;#34;Count&amp;#34;: 25, &amp;#34;Items&amp;#34;: [ { &amp;#34;OrderId&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;20160630-28176&amp;#34; }, &amp;#34;Username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; }, &amp;#34;Amount&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;88.3&amp;#34; } }, ... { &amp;#34;OrderId&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;20171129-28042&amp;#34; }, &amp;#34;Username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;alexdebrie&amp;#34; }, &amp;#34;Amount&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;83.</description>
    </item>
    
    <item>
      <title>如何在DynamoDB高效查询多项数据</title>
      <link>https://2cloudlab.com/nosql/querying/</link>
      <pubDate>Thu, 27 Feb 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/querying/</guid>
      <description>在DynamoDB中，查找操作的功能十分强大。它允许开发者根据相同的分区键来查询拥有不同排序键的数据项。本文将介绍查询操作的基础知识，分为以下几部分：
 根据某个分区键查找多项数据 基于排序键和使用关键字表达式来查询多项数据 使用映射表达式来选择要返回的属性信息  当继续后续的学习之前，你需要理解什么是DynamoDB的表达式。
根据某个分区键查找多项数据 在之前的章节里，我们实践了如何一次操作一项数据。这种操作适合于一些场景，比如：一次操作一个用户信息，这些信息可能是该用户的简介或姓名。
然而，在某些场景，这样的数据操作就不适用了，比如操作用户的订单。有时你可能只需要获取某个订单数据，但是，有的时候我们想获取某个用户的所有订单信息。如果每个订单的信息由不同的分区键识别，那么查找这些订单的效率会很慢。
接下来，让我们看看有什么更好的办法能够快速查找某个用户的所有订单。答案是使用Query操作，首先，我们的场景是获取用户为&amp;quot;daffyduck&amp;quot;的所有订单信息。注意：--key-condition-expression选项是非常关键的参数，这个参数定义了我们如何选择要返回的订单。如下所示：
$ aws dynamodb query \  --table-name UserOrdersTable \  --key-condition-expression &amp;#34;Username = :username&amp;#34; \  --expression-attribute-values &amp;#39;{ &amp;#34;:username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; } }&amp;#39; \  $LOCAL 运行以上指令将得到4个属于&amp;quot;daffyduck&amp;quot;的订单，如下所示：
{ &amp;#34;Count&amp;#34;: 4, &amp;#34;Items&amp;#34;: [ { &amp;#34;OrderId&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;20160630-28176&amp;#34; }, &amp;#34;Username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; }, &amp;#34;Amount&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;88.3&amp;#34; } }, { &amp;#34;OrderId&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;20170608-10171&amp;#34; }, &amp;#34;Username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; }, &amp;#34;Amount&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;18.</description>
    </item>
    
    <item>
      <title>如何在DynamoDB中同时操作多项数据</title>
      <link>https://2cloudlab.com/nosql/working-with-multiple-items/</link>
      <pubDate>Wed, 26 Feb 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/working-with-multiple-items/</guid>
      <description>在过去的章节里，我们一次只能操作一项数据&amp;ndash;比如插入，查找，更新以及删除单项数据。而在这篇文章里，我们将一次同时操作多项数据。从这章开始，我们将创建一张具有复合主键的表，并在该表中同时操作多项数据。
复合主键对于DynamoDB而言非常有用。它允许你通过一个查询操作就能获取一组相关的数据项，除此之外，它还有其它强大的用途。
本文将创建一张具有复合主键的表。然后我们将使用BatchWriteItem API来批量生成多项数据。后续的几篇文章将使用Query和Scan API作用到这些数据。
创建表 创建一张具有复合主键的表与创建一张具有简单主键的表类似，都需要定义属性和key schema。不同的是，你需要指定2个属性构成复合主键，而不是1个。 然后你需要指定其中一个属性是分区键，另外一个属性是排序键。
分区键决定了你的数据是如何划分的，而排序键则决定了具有相同分期键的数据项是有序的。分区键尤其重要-当使用Query操作时，你只能使用分区键。分区键与排序键组合在一起可以建立一对多的数据模型-因为一个相同的分区键下，可以有多个不同的排序键。
每当需要基于复合主键来对数据建模时，可以根据以下句子来填写空格处，最终构建正确的查询模式：
 &amp;ldquo;Give me all of the ____ from a particular ___.&amp;rdquo;
 放入第一个空格的属性应该是排序键，而放到最后一个空格的属性则是分区键。在以下示例中，我们将创建一张即包含User类型数据，同时也会包含Order类型数据的表：&amp;ldquo;UserOrdersTable&amp;rdquo;，其中每个User可以包含多个Orders。按照以上句子来构建查询模型，其最终的结果是：&amp;ldquo;返回该Username的所有OrderIds&amp;rdquo;。基于这句话，可以得出：Username是分区键，而OrderId则是排序键。
为了创建&amp;quot;UserOrdersTable&amp;rdquo;，需要使用CreateTable API：
$ aws dynamodb create-table \  --table-name UserOrdersTable \  --attribute-definitions &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;OrderId&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; } ]&amp;#39; \  --key-schema &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;HASH&amp;#34; }, { &amp;#34;AttributeName&amp;#34;: &amp;#34;OrderId&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;RANGE&amp;#34; } ]&amp;#39; \  --provisioned-throughput &amp;#39;{ &amp;#34;ReadCapacityUnits&amp;#34;: 1, &amp;#34;WriteCapacityUnits&amp;#34;: 1 }&amp;#39; \  $LOCAL 返回的结果如下所示：</description>
    </item>
    
    <item>
      <title>更新和删除数据项</title>
      <link>https://2cloudlab.com/nosql/updating-deleting-items/</link>
      <pubDate>Tue, 25 Feb 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/updating-deleting-items/</guid>
      <description>在这篇文章中，我们将学习如何向表中更新和删除单项数据。这是最后一篇关于单项数据操作的文章，后续的文章将涉及多个数据项的操作，这些操作主要有Queries和Scans。
更新单项数据 在之前的例子中，我们使用PutItem操作来向表中插入单项数据。我们也看到这种操作将会完全覆盖表中已存在的数据。为了不让这个操作覆盖已存在的数据项，我们在这个操作上使用了条件表达式。
有时需要处理这种场景：只更新某项数据的一个或者多个属性，而其它属性保持不变。为了处理这种场景，DynamoDB提供了UpdateItem操作，该操作允许开发者在不读取数据的情况下更新数据。
当使用UpdateItem操作时，你需要指定更新表达式，该表达式由2部分构成，分别是：更新的语义（比如是向数据项中添加属性还是移除属性）和表达式。
当使用更新表达式时，你必须提供以下更新的语义：
 SET: 这个操作用于向数据项中添加新的属性，或者覆盖已有属性 REMOVE: 该操作用于移除数据项中某一个属性 ADD: 对于数值类型的属性，该操作代表加或减；对于集合类型的属性，该操作代表向集合中插入元素 DELETE: 用于从集合中删除元素  让我们通过几个例子来了解更新操作的使用。
 使用带有SET语义的UpdateItem  在更新数据项时，最常用的更新操作是SET。比如，如果我想向某项数据添加一个新的属性或者覆盖已有的属性，那么这个SET操作会被用到。
让我们看看最开始的例子：PutItem，假设，我们想让已经添加的用户拥有属性DateOfBirth。 如果不使用UpdateItem操作，我们的做法是首先通过GetItem获取该数据项，然后通过PutItem插入一项包含DateOfBirth属性的数据项。然而通过UpdateItem操作，我们只需要直接插入属性DateOfBirth即可，如下所示：
$ aws dynamodb update-item \  --table-name Users \  --key &amp;#39;{ &amp;#34;Username&amp;#34;: {&amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34;} }&amp;#39; \  --update-expression &amp;#39;SET #dob = :dob&amp;#39; \  --expression-attribute-names &amp;#39;{ &amp;#34;#dob&amp;#34;: &amp;#34;DateOfBirth&amp;#34; }&amp;#39; \  --expression-attribute-values &amp;#39;{ &amp;#34;:dob&amp;#34;: {&amp;#34;S&amp;#34;: &amp;#34;1937-04-17&amp;#34;} }&amp;#39; \  $LOCAL 注意我们使用了选项--expression-attribute-names和--expression-attribute-values。
如果我们再次获取该数据项，那么我们不仅能看到之前的属性，而且还能看到新添的属性，如下所示：
$ aws dynamodb get-item \  --table-name Users \  --key &amp;#39;{ &amp;#34;Username&amp;#34;: {&amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34;} }&amp;#39; \  $LOCAL { &amp;#34;Item&amp;#34;: { &amp;#34;Username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; }, &amp;#34;DateOfBirth&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;1937-04-17&amp;#34; }, &amp;#34;Age&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;81&amp;#34; }, &amp;#34;Name&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;Daffy Duck&amp;#34; } } }  使用带有REMOVE语义的UpdateItem  带有REMOVE语义的UpdateItem操作与带有SET语义的UpdateItem操作相反&amp;ndash;它用于从一个数据项中删除指定属性。</description>
    </item>
    
    <item>
      <title>DynamoDB的基础表达式</title>
      <link>https://2cloudlab.com/nosql/expression-basics/</link>
      <pubDate>Mon, 24 Feb 2020 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/expression-basics/</guid>
      <description>本文是关于DynamoDB的表达式。表达式是DynamoDB的内置功能，它又细分为以下几类表达式：
 条件表达式只能与单项数据的操作配合起来使用，这些操作有PutItem，UpdateItem和DeleteItem。当你为单项数据的操作指定条件表达式时，只有当该表达式的验证结果为true时，该操作才能执行，对应的指令选项是--condition-expression 属性映射表达式通常会与读取数据项的操作配合起来使用，比如之前的GetItem例子就使用了属性映射表达式，它的作用在于仅返回该项数据的部分属性，对应的指令选项是--projection-expression 更新表达式用于更新已经存在的数据项上的某些属性，对应的指令选项是--update-expression 主键条件表达式通常会与查询操作（比如Query）一起使用，这类表达式的条件只能是与主键相关，对应的指令选项是--key-condition-expression 过滤表达式通常会与查询操作或遍历操作一起使用，它将作用于查询结果之上，对应的指令选项是--filter-expression  只有充分理解了这些表达式，才能更好地使用DynamoDB，进而享受DynamoDB给我们带来的好处。在这篇文章，我们将学习表达式的基础知识，包括使用表达式的属性名和属性值。紧接着，我们将基于上一章关于PutItem的例子来学习如何使用条件表达式。
表达式的基础知识 DynamoDB中的表达式只是一串字符串，它的内容是特定的逻辑表达式，而这个表达式将用来验证数据是否满足该条件。在这些表达式中，你可以应用一些比较操作符，比如&amp;quot;=&amp;rdquo;（相等），&amp;ldquo;&amp;gt;&amp;rdquo;（大于）或者&amp;quot;&amp;gt;=&amp;rdquo;（大于等于）。例如，以下表达式应用了&amp;quot;&amp;gt;=&amp;rdquo;：
&amp;#34;Age &amp;gt;= 21&amp;#34; 该表达式的作用在于：该操作只能作用于年龄在21岁及以上的用户，否则操作结果会出错。
 注意：以上表达式还无法生效，原因在于该表达式没有指定&amp;quot;21&amp;quot;的类型。为了使以上表达式生效，你需要指定expression attribute values，也就是使用指令属性--expression-attribute-values，这一点将在后面提到。
 除了可以在表达式中使用比较操作符，还可以在表达式中使用函数。这些函数是DynamoDB提供的，它们有：attribute_exists()，判断某项数据其属性是存在的；attribute_not_exists()，判断某项数据其属性是不存在的；begins_with()，判断某项数据其属性值是以某个子字符串开始的。
我们可以在表达式中使用attribute_not_exists()函数来判断某个订单是否已经发货了，其用法如下所示：
&amp;#34;attribute_not_exists(DateShipped)&amp;#34; 如果该订单有DateShipped属性，那么表明它已经发货了，否则表明它还在仓库中。DynamoDB提供的函数不多，所有的函数如下所示：
 attribute_exists(): 判断某项数据其属性是存在的 attribute_not_exists(): 判断某项数据其属性是不存在的 attribute_type(): 判断某项数据其属性的类型是指定的类型 begins_with(): 判断某项数据其属性值是以某个子字符串开始的 contains(): 如果该属性是字符串类型，则判断某项数据其属性值是包含某个子字符串的；如果该属性是集合类型（比如List或Map），则判断该属性是包含指定元素的 size(): 返回属性的大小，不同类型的属性，其大小的计算规则是不一样的。  关于表达式中的比较操作符和函数，读者可以参考官方文档。
表达式的占位符 之前的内容表明，表达式是一个具有逻辑运算的字符串，DynamoDB通过执行这个表达式来得到一个是或否的结果。然而，有的时候你需要一种更加清晰的方式来编写表达式，比如在表达式中使用变量，然后在其它地方提供变量值。
DynamoDB允许你使用--expression-attribute-names和--expression-attribute-values选项来编写更加清晰的表达式。通过这种做法，你可以在表达式中指定变量，然后分别使用以上选项来指定变量值，DynamoDB会将这些变量值自动替换掉表达式中的变量。接下来，让我们看看这2个选项的含义。
 --expression-attribute-names  有时，你希望针对一个属性编写表达式，但是由于DynamoDB的限制，你无法直接在表达式中使用该属性名，比如：
 你的属性名称刚好是DynamoDB中预留的关键字。DynamoDB预先保留了大量的关键字，其中包括了：&amp;ldquo;Date&amp;rdquo;，&amp;ldquo;Year&amp;quot;和&amp;quot;Name&amp;quot;等。如果你的属性名称恰巧在这些预留的关键字里，那么你需要借助这个选项来提供属性名称的占位符 你的属性名称中包含&amp;rdquo;.&amp;quot;。DynamoDB使用&amp;rdquo;.&amp;ldquo;来获取嵌套类型（比如Map类型）中的子项。如果你的属性名中包含了&amp;rdquo;.&amp;quot;，那么你需要借助这个选项来提供属性名称的占位符 你的属性名称开头包含数字。DynamoDB不允许表达式中的属性名称以数字开头，因此如果你的属性名称以数字开头，那么你需要借助这个选项来提供属性名称的占位符  在使用这个选项时，你只需要提供一个Map格式的属性名称集合。这个Map中的key是表达式中的占位符，而value是属性名称。例如，你可以为&amp;quot;Age&amp;quot;属性定义占位符&amp;rdquo;#a&amp;rdquo;，而这个占位符可用于表达式，具体示例如下所示：
--expression-attribute-names &amp;#39;{ &amp;#34;#a&amp;#34;: &amp;#34;Age&amp;#34; }&amp;#39;  当使用--expression-attribute-names时，占位符必须以&amp;rdquo;#&amp;ldquo;开头。
 在之前的GetItem的例子中，我们使用了--projection-expression选项来返回某项数据的部分属性。为了能够在该选项中使用占位符，我们需要将之前的例子改如下：
$ aws dynamodb get-item \  --table-name Users \  --projection-expression &amp;#34;#a, #u&amp;#34; \  --expression-attribute-names &amp;#39;{ &amp;#34;#a&amp;#34;: &amp;#34;Age&amp;#34;, &amp;#34;#u&amp;#34;: &amp;#34;Username&amp;#34; }&amp;#39; \  --key &amp;#39;{ &amp;#34;Username&amp;#34;: {&amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34;} }&amp;#39; \  $LOCAL { &amp;#34;Item&amp;#34;: { &amp;#34;Username&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;daffyduck&amp;#34; }, &amp;#34;Age&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;81&amp;#34; } } } 注意，在以上例子中，我们在--projection-expression中使用了2个占位符，分别是&amp;rdquo;#a&amp;quot;和&amp;rdquo;#u&amp;rdquo;。而这2个占位符定义在--expression-attribute-names选项中，分别对应&amp;quot;Age&amp;quot;和&amp;quot;Username&amp;quot;属性。</description>
    </item>
    
    <item>
      <title>在DynamoDB中插入和读取数据项</title>
      <link>https://2cloudlab.com/nosql/inserting-retrieving-items/</link>
      <pubDate>Sat, 23 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/inserting-retrieving-items/</guid>
      <description>数据项是DynamoDB的基础单元，每一张表都会包含多项数据。接下来，在本文中，我们将向DynamoDB中插入和读取数据项。我们将创建Users表，并为该表指定一个简单键：Username。接着，我们将操作2个基本的接口：PutItem和GetItem。下一篇文章，我们将在这篇文章的基础上应用表达式来实现更加复杂的查询功能。在这之后，我们将另起一篇文章来讲解如何更新和删除数据项。
 为了能顺利操作本文所列举的示例，请确保DynamoDB的环境已经准备好。注意：如果你使用的是本地版本的DynamoDB，那么请确保$LOCAL变量配置正确，如果使用的是AWS上的DynamoDB，那么在每一个命令后面无需追加这个参数。
 创建表 在演练本文列举的用例之前，首先需要创建一张表。我们将创建一张表&amp;quot;Users&amp;rdquo;，并为该表定义了一个简单主键：&amp;ldquo;Username&amp;rdquo;，它的类型是string。
当创建表时，你需要为主键或索引提供属性定义。这些属性定义包含了属性名和属性类型。在Users这张表中，我们使用&amp;quot;Username&amp;quot;作为主键，其类型是string（&amp;ldquo;S&amp;rdquo;）。除此之外，你还需要为该表定义KeySchema，其中指定了哪些属性构成主键以及这些属性是HASH键还是RANGE键。在以下示例中，属性&amp;quot;Username&amp;quot;构成了该表的简单主键。最后，你需要指定表名和表的吞吐单元，其中吞吐单元由读和写单元构成。在以下示例中，&amp;ldquo;Users&amp;quot;表的读写单元都是1，简单来说，越多的读写单元，单位时间内读写数据的速度越快和越多，反之亦然！
有了以上概念, 让我们运行以下指令来创建表&amp;quot;Users&amp;rdquo;:
$ aws dynamodb create-table \  --table-name Users \  --attribute-definitions &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; } ]&amp;#39; \  --key-schema &amp;#39;[ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;KeyType&amp;#34;: &amp;#34;HASH&amp;#34; } ]&amp;#39; \  --provisioned-throughput &amp;#39;{ &amp;#34;ReadCapacityUnits&amp;#34;: 1, &amp;#34;WriteCapacityUnits&amp;#34;: 1 }&amp;#39; \  $LOCAL 如果创建表的操作成功了，你将看到以下返回结果：
{ &amp;#34;TableDescription&amp;#34;: { &amp;#34;TableArn&amp;#34;: &amp;#34;arn:aws:dynamodb:ddblocal:000000000000:table/Users&amp;#34;, &amp;#34;AttributeDefinitions&amp;#34;: [ { &amp;#34;AttributeName&amp;#34;: &amp;#34;Username&amp;#34;, &amp;#34;AttributeType&amp;#34;: &amp;#34;S&amp;#34; } ], &amp;#34;ProvisionedThroughput&amp;#34;: { &amp;#34;NumberOfDecreasesToday&amp;#34;: 0, &amp;#34;WriteCapacityUnits&amp;#34;: 1, &amp;#34;LastIncreaseDateTime&amp;#34;: 0.</description>
    </item>
    
    <item>
      <title>DynamoDB中，每项数据（item）的构成单元</title>
      <link>https://2cloudlab.com/nosql/anatomy-of-an-item/</link>
      <pubDate>Fri, 22 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/anatomy-of-an-item/</guid>
      <description>DynamoDB中的每条数据是构成整个数据集的基础，它对应着关系型数据库中的某一张表中的某一行数据或者对应MongoDB中一个文档，又或者是编程当中的一个对象（比如一个用户对象）。每条数据由主键唯一标识，而主键是在创建表的时候指定的。除了主键之外，每条数据也可以包含其它属性，这些属性与主键组成了一条完整的数据单元（比如：一个用户数据由user_id, name, phone组成，其中user_id是主键）。每个属性（包括主键）都有对应类型，比如string，numbers，lists，sets等，当写入或查询数据的时候，这些类型都需要提供。在这篇文章中，我们将通过以下几个方面来讨论构成每项数据的基础单元：
 主键 属性 属性的类型  主键  表中的每项数据都由主键唯一标识
 每当创建一张表的时，你需要为该表指定一个主键。每项数据由主键唯一标识，而且每当向表中插入一项数据时，该项数据必须包含主键信息。
Dynamo支持2种主键。一种是简单主键，这种主键只使用了一个属性标识每一项数据，比如用户名或者订单编号。使用简单主键来写入或查询数据时有点类似于key-value数据库，比如Memcached。另外一种是复合主键，这种主键使用了2个属性来标识每一项数据。其中一个属性是分区键，它的作用在于将不同的数据划分到对应的分区。另外一个属性是排序键，它的作用是使所有具有相同分区键值的数据依据排序键进行排序。拥有复合主键的表，除了能够支持简单的写入和查询数据操作，还支持更多复杂的数据查询操作。
理解DynamoDB中表的主键对于数据建模至关重要。每当插入和更新数据时，主键都是必不可少的信息。
属性 每项数据都由多个属性构成，比如User表中的某一项数据有Name，Age，地址等属性，这些属性类似于关系型数据库中的列。DynamoDB表
DynamoDB表中每一项数据除了必须包含主键属性，其它属性不是必须的。DynamoDB是NoSQL数据库，因此它允许更加灵活的数据模型，而这一点在关系型数据库中是无法办到的。因为这种灵活的数据模型，你能在一张DynamoDB表中存储多种不同类型的数据，比如有一条Car数据，它包含产地，型号和生产年限等属性，同时在相同的表中也包含另外一条Pet数据，它包含类型，血型，年龄，颜色等属性。在DynamoDB中，一张表中同时包含不同类型的数据是常见的做法，这种做法会提高数据查询的效率！
属性的类型 当为每一项数据设置属性时，同时需要指定该属性的类型。可指定的类型有简单类型：比如，strings和numbers；也有复合类型：比如：lists，maps和sets。
每当更新或者插入数据时，需要为数据中的每一个属性指定其对应的类型。这些属性的设置需要借助一个map数据结构来完成，其中该map的keys是每一个属性名，而对应的values则是另外一个map，而这个map只有一个元素，其key是对应属性的类型，而value是对应属性的值。比如：你想存储一个用户数据，该数据包含3个属性，分别是姓名，年龄和角色，它们的类型分别是string，number和list，那么你需要为该用户数据设置如下属性信息：
{ &amp;#34;Name&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;Alex DeBrie&amp;#34; }, &amp;#34;Age&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;29&amp;#34; }, &amp;#34;Roles&amp;#34;: { &amp;#34;L&amp;#34;: [&amp;#34;Admin&amp;#34;, &amp;#34;User&amp;#34;] } } 在以上例子，我们存储了Name属性，其类型是string（通过&amp;quot;S&amp;quot;来代表），值为&amp;quot;Alex DeBrie&amp;rdquo;。此外，还存储了Age属性，其类型是number（通过&amp;quot;N&amp;quot;来代表），值为&amp;quot;29&amp;rdquo;。最后，还存储了Roles属性，其类型是list（通过&amp;quot;L&amp;quot;来代表），值为&amp;quot;Admin&amp;quot;和&amp;quot;User&amp;rdquo;。
同样，每当你从表中获取数据项时，其属性会以map的方式返回。其中，map中的keys是属性名，而values则是另外一个map，这个map的key是对应属性的类型，而value则是对应属性的值。例如，如果你使用GetItem API来获取以上用户数据，那么得到的结果如下所示：
{ &amp;#34;Item&amp;#34;: { &amp;#34;Name&amp;#34;: { &amp;#34;S&amp;#34;: &amp;#34;Alex DeBrie&amp;#34; }, &amp;#34;Age&amp;#34;: { &amp;#34;N&amp;#34;: &amp;#34;29&amp;#34; }, &amp;#34;Roles&amp;#34;: { &amp;#34;L&amp;#34;: [&amp;#34;Admin&amp;#34;, &amp;#34;User&amp;#34;] } } }  需要注意的是：Age属性的值&amp;quot;29&amp;quot;是字符串，因此为了得到数值类型29，那么需要在应用程序里将字符串转成数值类型。
 对以上属性类型有一些基本了解之后，让我们来看看不同的属性类型。每种属性类型都会以类型标识（比如&amp;quot;S&amp;quot;代表string，而&amp;quot;N&amp;quot;代表number）和用例开始介绍。</description>
    </item>
    
    <item>
      <title>NoSQL的学习资料</title>
      <link>https://2cloudlab.com/nosql/additional-reading/</link>
      <pubDate>Thu, 21 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/additional-reading/</guid>
      <description>这篇文章收录了一些关于NoSQL的英文资料。有的解释NoSQL为何能规模化而SQL却受到限制；有的涉及NoSQL的单表设计原则，以及解释为何需要使用单表；其中有一篇文章是关于如何将SQL中多张有关联的表转化成DynamoDB中的单张表。还有一些关于DynamoDB的视频资料，其中的内容讲述了NoSQL的设计原则，以及如何高效使用DynamoDB。读者可以通过这些学习资料来掌握NoSQL的理论知识，通过这些知识来设计既能支持100TBs以上数据又能输出稳定性能的数据应用方案。
文章:  SQL, NoSQL, and Scale: How DynamoDB scales where relational databases don&#39;t - This is a post of mine explaining the core architectural decisions that allow NoSQL databases to scale further than their SQL brethren. The What, Why, and When of Single-Table Design with DynamoDB - A deep look at what it means to do single-table design in DynamoDB and why you would want to. It also includes a few situations where you may want to avoid single-table design.</description>
    </item>
    
    <item>
      <title>DynamoDB的环境搭建</title>
      <link>https://2cloudlab.com/nosql/environment-setup/</link>
      <pubDate>Wed, 13 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/environment-setup/</guid>
      <description>DynamoDB是一个完全托管于AWS的NoSQL解决方案。开发者可以选择直接在AWS上创建一个DynamoDB的表或者将DynamoDB安装到本地。后续的内容将涉及DynamoDB的API，比如通过AWS CLI来操作DynamoDB。为了操作DynamoDB，我们需要搭建DynamoDB的环境。
安装 AWS CLI AWS CLI是AWS提供的命令行工具，开发者通过使用这个工具能够方便地使用AWS所提供的云服务，包括DynamoDB服务。运行以下命令来安装AWS CLI：
$ pip install awscli 如果在安装过程种遇到困难，可以参考这里进行安装。
获取认证和授权 如果你打算使用AWS提供的DynamoDB服务，那么你需要正确地设置认证和授权的权限，具体需要参考官方文档。
比较简单的一种方式是授予开发者所有关于DynamoDB操作的权限，其策略定义如下：
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;dynamodb:*&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34; } ] } 一旦你在AWS上申请了一个账号并得到了能够操作DynamoDB的凭证，那么你还需要将这个凭证通过以下方式设置到本地电脑
$ aws configure AWS Access Key ID [None]: AKIAIOSFODNN7EXAMPLE AWS Secret Access Key [None]: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY Default region name [None]: us-west-2 Default output format [None]: json 在本地搭建DynamoDB服务 AWS提供了可在本地运行的DynamoDB，它可以在本地运行，免除了凭证的设置和避免了使用云端DynamoDB所产生的费用。
想要在本地使用DynamoDB，那么根据以下指令下载和安装DynamoDB：
$ curl -O https://s3-us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.zip $ unzip dynamodb_local_latest.zip $ rm dynamodb_local_latest.</description>
    </item>
    
    <item>
      <title>关于Dynamo的论文</title>
      <link>https://2cloudlab.com/nosql/the-dynamo-paper/</link>
      <pubDate>Tue, 12 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/the-dynamo-paper/</guid>
      <description>在2004这一年，Amazon.com的增长速度很快，最终其Oracle上的数据规模达到极限，限制了其业务的发展。为了摆脱这种限制，Amazon开始考虑建立他们自己的数据库（注意：在公司内部搭建一个数据库系统是非常糟糕的想法）。在研发自家的数据库之后，亚马逊的工程师创建了创造了Amazon Dynamo数据库，这个数据库支撑了大部分Amazon.com业务，包括其购物车。
那些研发Amazon Dynamo数据库背后的工程师于2007年发布了关于Dynamo的论文。这篇论文描述了这群工程师在搭建高可用，key-value存储过程中为了满足Amazon.com业务场景所学到的经验。
这篇论文影响深远，并催生一大批NoSQL的解决方案，这些解决方案包括Apache Cassandra(最初由Facebook研发)和AWS提供的 SimpleDB以及DynamoDB（注意AWS团队和Amazon团队是2拨不同的团队，2者互不关联）。2012年，Amazon Web Services对外发布了DynamoDB，该服务借鉴了Dynamo的经验和原则，且完全托管在AWS上。
 想要了解为何DynamoDB存储100 TBs以上的数据，却依然能保持稳定的性能? 请参考这篇文章 SQL, NoSQL, and Scale: How DynamoDB scales where relational databases don&#39;t。
 Dynamo的几个关键点 非关系型数据模型
关系型数据模型可以用来为不同类型的数据建模（比如针对一个电商的用户和订单来建模）。通常，使用关系型数据建模的方式为数据建模，需要将关联的数据拆分成更小的数据单元，以便这些数据是不重复的，这就是关系型数据库中著名的第一范式。其做法是，如果某类实体数据想要使用另外一类实体数据（比如将订单和用户关联），那么只需要将2类不同的实体数据存储在不同的表格，然后通过外键的方式来关联这2类数据以及通过JOIN操作来拼接和获取这2类数据。此时，你只需要修改某个实体（比如某个用户的用户名），那么另一个数据实体（比如订单所属的用户名也发生了变化）所引用的数据也会因此而变化。
然而，Amazon.com工程师在收集数据库需求时发现了一个非常有趣的结果：
 大约70%对数据库的操作是key-value类型，这些操作仅仅使用主键来获取单条数据。大约20%的操作会返回一个数据集，但是这些数据集均来自于同一张表。
&amp;ndash; Werner Vogels, A Decade of Dynamo
 以上发现是问题的关键 &amp;ndash; 90%的操作不会使用JOIN功能，而这一功能却是关系型数据库的核心。
JOIN操作非常消耗资源。当面对大规模的数据时，工程师通常会将数据复原为一个整体(拒绝使用第一范式)来避免使用JOIN操作而导致的高延时。 通过这种方式来降低响应延时的代价是增加了应用的复杂性&amp;ndash;此时应用程序需要考虑数据的完整性而不是数据库本身。
Amazon.com的工程师已经采用了以上方法来降低延时。实际上，正是意识到亚马逊工程师所需的并不是关系型数据模型，才使得Dynamo设计师重新评估关系型数据库的其它方面。
可用性比数据一致性更加重要
大部分关系型数据库使用strongly consistent model来操作数据。简而言之，这种模式会使得所有客户端在同一时间能够获得相同的数据(想想这个场景:一个用户正在写数据，而多个用户正在读这个写的数据)。
让我们通过Twitter作为例子. 假设2:30PM，Bob在Virginia 发布了一条关于猫的信息。在信息发布之后，有2个用户查看了Bob发布的信息，他们分别是他的邻居Cheryl和住在新加坡的叔叔Jeffrey。如果Twitter使用strongly-consistent model，Cheryl和Jeffrey会看到Bob发布的关于猫的信息。
用这种方式来确保看到一致的信息不是最理想的，原因有以下几点:
首先，考虑地理位置的因素。Twitter选择一台数据库服务来实施strong consistency。该数据库服务位于Virginia，离Bob和Cheryl很近。这使得该服务的响应很快能到达Bob和Cheryl，但是到达Jeffrey所需的时间就变长了，因为猫的信息会跨越大西洋从Virginia到Singapore。从地理上来分析，Bob和Cheryl获取猫的信息所花的时间显然会比Jeffrey所需的时间短。这种只选择一台数据库服务来实施strong consistency model的结果是，一些用户，像Jeffrey，获取信息的时间会变得漫长起来。那么有什么方式能让这些用户获取信息的时间缩短?
抛弃只有一台数据服务的做法，Twitter可以选择2台数据库服务，每台数据库服务上的数据是相同的&amp;ndash;其中一台放到Virginia另外一台放到Singapore。此时，如果我们依然需要实施strong consistency model， 那么就意味着同一个用户从以上2台数据库服务在同一时间获取同一份信息，其得到的数据是一样的。这也意味着Twitter需要在数据库服务上实现复杂的同步算法&amp;ndash;在Bob发布的关于猫的信息提交到数据库之前，这些信息必须成功地提交到这2台数据服务上。此时，Bob的提交将往返于整个大西洋，最终导致用户的写操作变得更慢。
在Dynamo paper中，Amazon指出strong consistency在其业务场景中并不重要。具体应用到我们的例子中的场景是:Jeffrey与Cheryl在同一时间将看到不同的版本的关于猫的信息。数据库服务可以使用eventual consistency model来同步数据。也就是说最终不同用户会看到相同的信息。Jeffrey最终会看到Bob发布的关于猫的信息，而这条信息于2:32 PM传送到Singapore，即便是这条信息于2:30 PM传送到Virginia。
Strong consistency model对于某些场景相当重要-比如银行账户中的余额-但对于某些场景并不重要，比如Twitter示例或者Amazon的购物车系统。 去掉strong consistency model的使用而换成eventual consistency model大大促进了Dynamo的发展。对于Twitter示例或者Amazon的购物车系统这类业务场景，速度和可用性比同时获取相同数据更加重要。通过减弱关系型数据库的consistency model，Dynamo的工程师能够研发更加适合Amazon.</description>
    </item>
    
    <item>
      <title>DynamoDB的关键概念</title>
      <link>https://2cloudlab.com/nosql/key-concepts/</link>
      <pubDate>Mon, 11 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/key-concepts/</guid>
      <description>在使用DynamoDB之前，我们需要了解一些基础概念，这些概念涉及了：表（tables），数据项（items）和每项数据的属性（attributes）、主键（primary keys），有简单主键（Partition Key）和复合主键（Partition Key + Sort Key）、附加索引（secondary indexes）、DynamoDB的读写能力。
本文将讨论关于DynamoDB的关键概念。完成这一章的学习之后，你将对以下概念有进一步的认识：
 表（tables），数据项（items）和每项数据的属性（attributes） 主键（primary keys），有简单主键（Partition Key）和复合主键（Partition Key + Sort Key） 附加索引（secondary indexes） DynamoDB的读写能力  表（tables），数据项（items）和每项数据的属性（attributes） 表（tables），数据项（items）和每项数据的属性（attributes）是DynamoDB的基础构建单元。
表是数据项的集合，不同类型的数据项都可以放到一张表里。例如：有一张Users表，该表存储了每一个用户的信息；有一张Orders表，该表存储了用户的所有订单信息。表的概念有点类似于关系型数据库中的表或MongoDB中的集合，与它们不同的是，DynamoDB中的表经常会存储不同类型的数据，比如用户信息以及该用户的所有订单信息会存储在同一张表中。
每条数据在表里就是一条记录（包含了多个属性（Attributes））。在表里，每条数据由主键（Primary Key）唯一确定。比如在Users表中，一条数据对应一个用户，这条数据包括了用户名，性别和住址等用户相关的信息。每条数据类似于关系型数据库表中的某一行或者MongoDB中的一个文档数据。
数据的属性组合成了每条数据，每条数据由多个数据属性构成。比如：一条用户数据包含了年龄属性，该属性存储了该用户的年龄。属性类似于关系型数据库表中的列或MongoDB中的属性。DynamoDB要求每一项数据都至少包含构成该数据主键的属性。
主键（Primary Key） 表中的每项数据由主键唯一标识。在创建表的时候，必须定义由哪些属性构成主键，当向表中新添数据的时候，该数据至少需要包含主键信息。
主键的类型有2类：简单主键和复合主键。前者仅由分区键（Partition Key）构成，而后者由分区键（Partiti Key）和排序键（Sort Key）组成。
简单主键类似于Memcached中的Key和SQL表中的主键。比如：用户名可以作为表Users的简单主键。
复合主键则更加复杂。你需要为表中的每一条数据提供分区键和排序键。排序键的作用在于使得同一分区的数据按照排序键的值进行排序。例如：某个用户的所有订单拥有相同的分区键（如：用户名），但每个订单的排序键（如：订单编号）是不相同的。
这里需要提醒的是：表中的每条数据是由主键唯一标识的。当使用复合主键来标识数据时，不同的数据可以拥有相同的分区键，此时，这些数据必须使用不同的排序键。由相同的分区键和不同的排序键构成的主键唯一标识了表中每一条数据。
复合主键可以支持复杂的数据查询模式。这些查询模式有：根据分区键来获取表中的数据；使用排序键来缩小查询范围。
读者可以根据拆解数据项来理解数据项的基本构成。
附加索引（Secondary Index） 主键唯一标识了表中的每一项数据，根据主键可以从表中获取到对应的数据项。然而有的时候，你需要根据其它模式来获取数据，比如你想查询订单金额超过某个范围的订单，而此时该表的Partition Key和Sort Key分别是用户名和订单号。使用该表的复合主键来满足这种查询显然是低效的，因此这个时候需要借助DynamoDB的附件索引来满足这一查询模式。附加索引有2种：local secondary index和global secondary index。
local secondary index使用了与表相同的分区键但是不同的排序键来构成索引。假设有一张Orders表，你想读取某个用户的所有订单，这些订单需要以订购数量（Amount）进行降序排序。此时，你只需要为Orders表创建一个local secondary index，该索引的分区键是用户ID（CustomerId），排序键是订单的订购数量（Amount）。开发者使用这个索引就能高效地获取某个用户的订单，并按照订单的数量进行排序。
global secondary index使用了与表完全不同的分区键和排序键来构成索引。你可以选择其它属性（不包含表的分区键）作为索引的分区键，从而构成该索引的简单主键，当然你也可以选择2个属性来构成索引的主键。假设有一张表，我们可以在这张表上定义一个global secondary index，该索引的分区键是订单号（OrderID），而排序键可以不设置，从而构成一个简单的主键。接着我们可以通过这个索引来根据订单号高效获取某个具体的订单，而无需通过查找用户和用户名下的订单这种低效的方式来查找。
附加索引是一个异常复杂的话题，但是这个功能却非常实用。它是实现不同查询模式的基础，想要深入了解和应用附件索引，读者可以前往这里。
读和写单元 当你使用MySQL，Postgres和MongoDB的时候，你需要启动一个服务器来运行这些数据库实例。你必须为这个服务器配置CPU，内存以及磁盘存储等。
而使用DynamoDB时，你不需要自己启动这些服务器，你只需要为创建的表指定读和写的单元，AWS就能自动地帮你启动服务器，并根据这些读写单元来启动服务器。这些读写单元限制了读写数据的吞吐量（KB/S），越多的读写单元其吞吐量会越大。与自己启动服务器来运行数据库实例的方式相比，这种方式的计费模式更加贴近真实的使用费用。
DynamoDB也能够自动增加和减少表的读写单元。这使得在数据使用的高峰期时，读写单元会自动增多，而在低峰期时，该读写单元会自动减少。通过这种根据实际使用情况来为表动态分配读写单元的方式能够减少支出。
下一步学习计划 如果你对DynamoDB的内部实现感兴趣，不妨去看看Dynamo Paper。如果不感兴趣，那么可以从搭建DynamoDB的环境开始，接着阅读对单条数据进行操作中的内容来理解数据的基本构成。
参考  原文链接  </description>
    </item>
    
    <item>
      <title>什么是DynamoDB？</title>
      <link>https://2cloudlab.com/nosql/what-is-dynamo-db/</link>
      <pubDate>Sun, 10 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/what-is-dynamo-db/</guid>
      <description>DynamoDB是一个由AWS提供的NoSQL数据库服务。它完全托管于AWS，开发者只需要定义数据访问模式以及一些关键信息，就能通过HTTP API来使用它。它具有以下特点：
 随着数据量的剧增，它依然能够提供稳定的性能输出 它完全由AWS管理。开发人员不需要SSH到其服务器，不需要管理服务器，不需在服务器上更新OS补丁和加密库等 它提供了简单的API，这些API能够对数据进行增删改查，除此之外，开发者也能根据获取数据的场景来定义查询模式  DynamoDB适用于以下场景：
需存储大量数据同时要求低延迟的应用服务。随着应用服务的数据量增多，JOINs和高级的SQL操作会大大降低关系型数据库的性能，从而导致应用服务的性能变差。如果使用DynamoDB, 对任何数据量（即使超过100 TBs）的查询操作，其延时也能够确定在某个具体的范围。
AWS Serverless服务。AWS Lambda服务提供了能自动弹性伸缩，无状态且短暂的计算能力。开发者只需要定义事件就能触发并应用这些计算能力。DynamoDB对外提供了HTTP API，开发者可以通过HTTP API来操作DynamoDB。开发者可以使用IAM roles来为DynamoDB进行认证(你是谁)和授权(你拥有哪些权限，比如读或者读写某张表)。这些特性使得DynamoDB特别适用于Serverless服务。
对数据具有确定且简单的访问模式(比如根据国家来获取所有星巴克的门店)。如果你编写了一个推荐系统，并根据用户的偏好来推荐物品，那么把DynamoDB作为数据基础，能够为推荐系统提供更快且性能稳定的key-value访问模式。
准备好学习更多关于DynamoDB的知识？ 这个系列的文章将以一些关键的概念开始，学习tables，items以及关于DynamoDB的其它组成部分。如果你急于了解DynamoDB背后所应用的计算机科学理论，那么可以参考Dynamo Paper。
如果你只是想动手练练，那么可以从准备环境以及对单条数据进行操作开始。紧接着，你可以通过学习对多条数据进行操作来掌握DynamoDB的Queries和Scans功能。
以上只是一些基础知识，想要了解更多的高阶知识，可以参考secondary indexes和DynamoDB Streams。
如果想要获得更多关于DynamoDB的学习资料，那么这里将是一个不错的地方。
 原文链接  </description>
    </item>
    
  </channel>
</rss>