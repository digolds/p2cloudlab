<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data-Intensive on 2cloudlab | 企业数字化转型的催化剂</title>
    <link>https://2cloudlab.com/tags/data-intensive/</link>
    <description>Recent content in Data-Intensive on 2cloudlab | 企业数字化转型的催化剂</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Feb 2019 12:27:38 +0600</lastBuildDate>
    
	<atom:link href="https://2cloudlab.com/tags/data-intensive/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>NoSQL的学习资料</title>
      <link>https://2cloudlab.com/nosql/additional-reading/</link>
      <pubDate>Thu, 21 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/additional-reading/</guid>
      <description>这篇文章收录了一些关于NoSQL的英文资料。有的解释NoSQL为何能规模化而SQL却受到限制；有的涉及NoSQL的单表设计原则，以及解释为何需要使用单表；其中有一篇文章是关于如何将SQL中多张有关联的表转化成DynamoDB中的单张表。还有一些关于DynamoDB的视频资料，其中的内容讲述了NoSQL的设计原则，以及如何高效使用DynamoDB。读者可以通过这些学习资料来掌握NoSQL的理论知识，通过这些知识来设计既能支持100TBs以上数据又能输出稳定性能的数据应用方案。
文章:  SQL, NoSQL, and Scale: How DynamoDB scales where relational databases don&#39;t - This is a post of mine explaining the core architectural decisions that allow NoSQL databases to scale further than their SQL brethren. The What, Why, and When of Single-Table Design with DynamoDB - A deep look at what it means to do single-table design in DynamoDB and why you would want to. It also includes a few situations where you may want to avoid single-table design.</description>
    </item>
    
    <item>
      <title>DynamoDB的环境搭建</title>
      <link>https://2cloudlab.com/nosql/environment-setup/</link>
      <pubDate>Wed, 13 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/environment-setup/</guid>
      <description>DynamoDB是一个完全托管于AWS的NoSQL解决方案。开发者可以选择直接在AWS上创建一个DynamoDB的表或者将DynamoDB安装到本地。后续的内容将涉及DynamoDB的API，比如通过AWS CLI来操作DynamoDB。为了操作DynamoDB，我们需要搭建DynamoDB的环境。
安装 AWS CLI AWS CLI是AWS提供的命令行工具，开发者通过使用这个工具能够方便地使用AWS所提供的云服务，包括DynamoDB服务。运行以下命令来安装AWS CLI：
$ pip install awscli 如果在安装过程种遇到困难，可以参考这里进行安装。
获取认证和授权 如果你打算使用AWS提供的DynamoDB服务，那么你需要正确地设置认证和授权的权限，具体需要参考官方文档。
比较简单的一种方式是授予开发者所有关于DynamoDB操作的权限，其策略定义如下：
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;dynamodb:*&amp;#34; ], &amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34; } ] } 一旦你在AWS上申请了一个账号并得到了能够操作DynamoDB的凭证，那么你还需要将这个凭证通过以下方式设置到本地电脑
$ aws configure AWS Access Key ID [None]: AKIAIOSFODNN7EXAMPLE AWS Secret Access Key [None]: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY Default region name [None]: us-west-2 Default output format [None]: json 在本地搭建DynamoDB服务 AWS提供了可在本地运行的DynamoDB，它可以在本地运行，免除了凭证的设置和避免了使用云端DynamoDB所产生的费用。
想要在本地使用DynamoDB，那么根据以下指令下载和安装DynamoDB：
$ curl -O https://s3-us-west-2.amazonaws.com/dynamodb-local/dynamodb_local_latest.zip $ unzip dynamodb_local_latest.zip $ rm dynamodb_local_latest.</description>
    </item>
    
    <item>
      <title>关于Dynamo的论文</title>
      <link>https://2cloudlab.com/nosql/the-dynamo-paper/</link>
      <pubDate>Tue, 12 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/the-dynamo-paper/</guid>
      <description>在2004这一年，Amazon.com的增长速度很快，最终其Oracle上的数据规模达到极限，限制了其业务的发展。为了摆脱这种限制，Amazon开始考虑建立他们自己的数据库（注意：在公司内部搭建一个数据库系统是非常糟糕的想法）。在研发自家的数据库之后，亚马逊的工程师创建了创造了Amazon Dynamo数据库，这个数据库支撑了大部分Amazon.com业务，包括其购物车。
那些研发Amazon Dynamo数据库背后的工程师于2007年发布了关于Dynamo的论文。这篇论文描述了这群工程师在搭建高可用，key-value存储过程中为了满足Amazon.com业务场景所学到的经验。
这篇论文影响深远，并催生一大批NoSQL的解决方案，这些解决方案包括Apache Cassandra(最初由Facebook研发)和AWS提供的 SimpleDB以及DynamoDB（注意AWS团队和Amazon团队是2拨不同的团队，2者互不关联）。2012年，Amazon Web Services对外发布了DynamoDB，该服务借鉴了Dynamo的经验和原则，且完全托管在AWS上。
 想要了解为何DynamoDB存储100 TBs以上的数据，却依然能保持稳定的性能? 请参考这篇文章 SQL, NoSQL, and Scale: How DynamoDB scales where relational databases don&#39;t。
 Dynamo的几个关键点 非关系型数据模型
关系型数据模型可以用来为不同类型的数据建模（比如针对一个电商的用户和订单来建模）。通常，使用关系型数据建模的方式为数据建模，需要将关联的数据拆分成更小的数据单元，以便这些数据是不重复的，这就是关系型数据库中著名的第一范式。其做法是，如果某类实体数据想要使用另外一类实体数据（比如将订单和用户关联），那么只需要将2类不同的实体数据存储在不同的表格，然后通过外键的方式来关联这2类数据以及通过JOIN操作来拼接和获取这2类数据。此时，你只需要修改某个实体（比如某个用户的用户名），那么另一个数据实体（比如订单所属的用户名也发生了变化）所引用的数据也会因此而变化。
然而，Amazon.com工程师在收集数据库需求时发现了一个非常有趣的结果：
 大约70%对数据库的操作是key-value类型，这些操作仅仅使用主键来获取单条数据。大约20%的操作会返回一个数据集，但是这些数据集均来自于同一张表。
&amp;ndash; Werner Vogels, A Decade of Dynamo
 以上发现是问题的关键 &amp;ndash; 90%的操作不会使用JOIN功能，而这一功能却是关系型数据库的核心。
JOIN操作非常消耗资源。当面对大规模的数据时，工程师通常会将数据复原为一个整体(拒绝使用第一范式)来避免使用JOIN操作而导致的高延时。 通过这种方式来降低响应延时的代价是增加了应用的复杂性&amp;ndash;此时应用程序需要考虑数据的完整性而不是数据库本身。
Amazon.com的工程师已经采用了以上方法来降低延时。实际上，正是意识到亚马逊工程师所需的并不是关系型数据模型，才使得Dynamo设计师重新评估关系型数据库的其它方面。
可用性比数据一致性更加重要
大部分关系型数据库使用strongly consistent model来操作数据。简而言之，这种模式会使得所有客户端在同一时间能够获得相同的数据(想想这个场景:一个用户正在写数据，而多个用户正在读这个写的数据)。
让我们通过Twitter作为例子. 假设2:30PM，Bob在Virginia 发布了一条关于猫的信息。在信息发布之后，有2个用户查看了Bob发布的信息，他们分别是他的邻居Cheryl和住在新加坡的叔叔Jeffrey。如果Twitter使用strongly-consistent model，Cheryl和Jeffrey会看到Bob发布的关于猫的信息。
用这种方式来确保看到一致的信息不是最理想的，原因有以下几点:
首先，考虑地理位置的因素。Twitter选择一台数据库服务来实施strong consistency。该数据库服务位于Virginia，离Bob和Cheryl很近。这使得该服务的响应很快能到达Bob和Cheryl，但是到达Jeffrey所需的时间就变长了，因为猫的信息会跨越大西洋从Virginia到Singapore。从地理上来分析，Bob和Cheryl获取猫的信息所花的时间显然会比Jeffrey所需的时间短。这种只选择一台数据库服务来实施strong consistency model的结果是，一些用户，像Jeffrey，获取信息的时间会变得漫长起来。那么有什么方式能让这些用户获取信息的时间缩短?
抛弃只有一台数据服务的做法，Twitter可以选择2台数据库服务，每台数据库服务上的数据是相同的&amp;ndash;其中一台放到Virginia另外一台放到Singapore。此时，如果我们依然需要实施strong consistency model， 那么就意味着同一个用户从以上2台数据库服务在同一时间获取同一份信息，其得到的数据是一样的。这也意味着Twitter需要在数据库服务上实现复杂的同步算法&amp;ndash;在Bob发布的关于猫的信息提交到数据库之前，这些信息必须成功地提交到这2台数据服务上。此时，Bob的提交将往返于整个大西洋，最终导致用户的写操作变得更慢。
在Dynamo paper中，Amazon指出strong consistency在其业务场景中并不重要。具体应用到我们的例子中的场景是:Jeffrey与Cheryl在同一时间将看到不同的版本的关于猫的信息。数据库服务可以使用eventual consistency model来同步数据。也就是说最终不同用户会看到相同的信息。Jeffrey最终会看到Bob发布的关于猫的信息，而这条信息于2:32 PM传送到Singapore，即便是这条信息于2:30 PM传送到Virginia。
Strong consistency model对于某些场景相当重要-比如银行账户中的余额-但对于某些场景并不重要，比如Twitter示例或者Amazon的购物车系统。 去掉strong consistency model的使用而换成eventual consistency model大大促进了Dynamo的发展。对于Twitter示例或者Amazon的购物车系统这类业务场景，速度和可用性比同时获取相同数据更加重要。通过减弱关系型数据库的consistency model，Dynamo的工程师能够研发更加适合Amazon.</description>
    </item>
    
    <item>
      <title>DynamoDB的关键概念</title>
      <link>https://2cloudlab.com/nosql/key-concepts/</link>
      <pubDate>Mon, 11 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/key-concepts/</guid>
      <description>在使用DynamoDB之前，我们需要了解一些基础概念，这些概念涉及了：表（tables），数据项（items）和每项数据的属性（attributes）、主键（primary keys），有简单主键（Partition Key）和复合主键（Partition Key + Sort Key）、附加索引（secondary indexes）、DynamoDB的读写能力。
本文将讨论关于DynamoDB的关键概念。完成这一章的学习之后，你将对以下概念有进一步的认识：
 表（tables），数据项（items）和每项数据的属性（attributes） 主键（primary keys），有简单主键（Partition Key）和复合主键（Partition Key + Sort Key） 附加索引（secondary indexes） DynamoDB的读写能力  表（tables），数据项（items）和每项数据的属性（attributes） 表（tables），数据项（items）和每项数据的属性（attributes）是DynamoDB的基础构建单元。
表是数据项的集合，不同类型的数据项都可以放到一张表里。例如：有一张Users表，该表存储了每一个用户的信息；有一张Orders表，该表存储了用户的所有订单信息。表的概念有点类似于关系型数据库中的表或MongoDB中的集合，与它们不同的是，DynamoDB中的表经常会存储不同类型的数据，比如用户信息以及该用户的所有订单信息会存储在同一张表中。
每条数据在表里就是一条记录（包含了多个属性（Attributes））。在表里，每条数据由主键（Primary Key）唯一确定。比如在Users表中，一条数据对应一个用户，这条数据包括了用户名，性别和住址等用户相关的信息。每条数据类似于关系型数据库表中的某一行或者MongoDB中的一个文档数据。
数据的属性组合成了每条数据，每条数据由多个数据属性构成。比如：一条用户数据包含了年龄属性，该属性存储了该用户的年龄。属性类似于关系型数据库表中的列或MongoDB中的属性。DynamoDB要求每一项数据都至少包含构成该数据主键的属性。
主键（Primary Key） 表中的每项数据由主键唯一标识。在创建表的时候，必须定义由哪些属性构成主键，当向表中新添数据的时候，该数据至少需要包含主键信息。
主键的类型有2类：简单主键和复合主键。前者仅由分区键（Partition Key）构成，而后者由分区键（Partiti Key）和排序键（Sort Key）组成。
简单主键类似于Memcached中的Key和SQL表中的主键。比如：用户名可以作为表Users的简单主键。
复合主键则更加复杂。你需要为表中的每一条数据提供分区键和排序键。排序键的作用在于使得同一分区的数据按照排序键的值进行排序。例如：某个用户的所有订单拥有相同的分区键（如：用户名），但每个订单的排序键（如：订单编号）是不相同的。
这里需要提醒的是：表中的每条数据是由主键唯一标识的。当使用复合主键来标识数据时，不同的数据可以拥有相同的分区键，此时，这些数据必须使用不同的排序键。由相同的分区键和不同的排序键构成的主键唯一标识了表中每一条数据。
复合主键可以支持复杂的数据查询模式。这些查询模式有：根据分区键来获取表中的数据；使用排序键来缩小查询范围。
读者可以根据拆解数据项来理解数据项的基本构成。
附加索引（Secondary Index） 主键唯一标识了表中的每一项数据，根据主键可以从表中获取到对应的数据项。然而有的时候，你需要根据其它模式来获取数据，比如你想查询订单金额超过某个范围的订单，而此时该表的Partition Key和Sort Key分别是用户名和订单号。使用该表的复合主键来满足这种查询显然是低效的，因此这个时候需要借助DynamoDB的附件索引来满足这一查询模式。附加索引有2种：local secondary index和global secondary index。
local secondary index使用了与表相同的分区键但是不同的排序键来构成索引。假设有一张Orders表，你想读取某个用户的所有订单，这些订单需要以订购数量（Amount）进行降序排序。此时，你只需要为Orders表创建一个local secondary index，该索引的分区键是用户ID（CustomerId），排序键是订单的订购数量（Amount）。开发者使用这个索引就能高效地获取某个用户的订单，并按照订单的数量进行排序。
global secondary index使用了与表完全不同的分区键和排序键来构成索引。你可以选择其它属性（不包含表的分区键）作为索引的分区键，从而构成该索引的简单主键，当然你也可以选择2个属性来构成索引的主键。假设有一张表，我们可以在这张表上定义一个global secondary index，该索引的分区键是订单号（OrderID），而排序键可以不设置，从而构成一个简单的主键。接着我们可以通过这个索引来根据订单号高效获取某个具体的订单，而无需通过查找用户和用户名下的订单这种低效的方式来查找。
附加索引是一个异常复杂的话题，但是这个功能却非常实用。它是实现不同查询模式的基础，想要深入了解和应用附件索引，读者可以前往这里。
读和写单元 当你使用MySQL，Postgres和MongoDB的时候，你需要启动一个服务器来运行这些数据库实例。你必须为这个服务器配置CPU，内存以及磁盘存储等。
而使用DynamoDB时，你不需要自己启动这些服务器，你只需要为创建的表指定读和写的单元，AWS就能自动地帮你启动服务器，并根据这些读写单元来启动服务器。这些读写单元限制了读写数据的吞吐量（KB/S），越多的读写单元其吞吐量会越大。与自己启动服务器来运行数据库实例的方式相比，这种方式的计费模式更加贴近真实的使用费用。
DynamoDB也能够自动增加和减少表的读写单元。这使得在数据使用的高峰期时，读写单元会自动增多，而在低峰期时，该读写单元会自动减少。通过这种根据实际使用情况来为表动态分配读写单元的方式能够减少支出。
下一步学习计划 如果你对DynamoDB的内部实现感兴趣，不妨去看看Dynamo Paper。如果不感兴趣，那么可以从搭建DynamoDB的环境开始，接着阅读对单条数据进行操作中的内容来理解数据的基本构成。
参考  原文链接  </description>
    </item>
    
    <item>
      <title>什么是DynamoDB？</title>
      <link>https://2cloudlab.com/nosql/what-is-dynamo-db/</link>
      <pubDate>Sun, 10 Feb 2019 12:27:38 +0600</pubDate>
      
      <guid>https://2cloudlab.com/nosql/what-is-dynamo-db/</guid>
      <description>DynamoDB是一个由AWS提供的NoSQL数据库服务。它完全托管于AWS，开发者只需要定义数据访问模式以及一些关键信息，就能通过HTTP API来使用它。它具有以下特点：
 随着数据量的剧增，它依然能够提供稳定的性能输出 它完全由AWS管理。开发人员不需要SSH到其服务器，不需要管理服务器，不需在服务器上更新OS补丁和加密库等 它提供了简单的API，这些API能够对数据进行增删改查，除此之外，开发者也能根据获取数据的场景来定义查询模式  DynamoDB适用于以下场景：
需存储大量数据同时要求低延迟的应用服务。随着应用服务的数据量增多，JOINs和高级的SQL操作会大大降低关系型数据库的性能，从而导致应用服务的性能变差。如果使用DynamoDB, 对任何数据量（即使超过100 TBs）的查询操作，其延时也能够确定在某个具体的范围。
AWS Serverless服务。AWS Lambda服务提供了能自动弹性伸缩，无状态且短暂的计算能力。开发者只需要定义事件就能触发并应用这些计算能力。DynamoDB对外提供了HTTP API，开发者可以通过HTTP API来操作DynamoDB。开发者可以使用IAM roles来为DynamoDB进行认证(你是谁)和授权(你拥有哪些权限，比如读或者读写某张表)。这些特性使得DynamoDB特别适用于Serverless服务。
对数据具有确定且简单的访问模式(比如根据国家来获取所有星巴克的门店)。如果你编写了一个推荐系统，并根据用户的偏好来推荐物品，那么把DynamoDB作为数据基础，能够为推荐系统提供更快且性能稳定的key-value访问模式。
准备好学习更多关于DynamoDB的知识？ 这个系列的文章将以一些关键的概念开始，学习tables，items以及关于DynamoDB的其它组成部分。如果你急于了解DynamoDB背后所应用的计算机科学理论，那么可以参考Dynamo Paper。
如果你只是想动手练练，那么可以从准备环境以及对单条数据进行操作开始。紧接着，你可以通过学习对多条数据进行操作来掌握DynamoDB的Queries和Scans功能。
以上只是一些基础知识，想要了解更多的高阶知识，可以参考secondary indexes和DynamoDB Streams。
如果想要获得更多关于DynamoDB的学习资料，那么这里将是一个不错的地方。
 原文链接  </description>
    </item>
    
  </channel>
</rss>